{"version":3,"file":"index242.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs"],"sourcesContent":["import { ALPHA_MODES } from \"@pixi/constants\";\nimport { settings } from \"@pixi/settings\";\nimport { BaseImageResource } from \"./BaseImageResource.mjs\";\nclass ImageResource extends BaseImageResource {\n  /**\n   * @param source - image source or URL\n   * @param options\n   * @param {boolean} [options.autoLoad=true] - start loading process\n   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n   *        a bitmap before upload\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n   */\n  constructor(source, options) {\n    if (options = options || {}, typeof source == \"string\") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;\n    }\n    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == \"number\" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Returns a promise when image will be loaded and processed.\n   * @param createBitmap - whether process image into bitmap\n   */\n  load(createBitmap) {\n    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));\n      };\n      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = (event) => {\n        reject(event), this.onError.emit(event);\n      });\n    }), this._load);\n  }\n  /**\n   * Called when we need to convert image into BitmapImage.\n   * Can be called multiple times, real promise is cached inside.\n   * @returns - Cached promise to fill that bitmap\n   */\n  process() {\n    const source = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    const createImageBitmap = globalThis.createImageBitmap, cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    return this._process = fetch(\n      source.src,\n      {\n        mode: cors ? \"cors\" : \"no-cors\"\n      }\n    ).then((r) => r.blob()).then((blob) => createImageBitmap(\n      blob,\n      0,\n      0,\n      source.width,\n      source.height,\n      {\n        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n      }\n    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;\n  }\n  /**\n   * Upload the image resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode == \"number\" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)\n      return super.upload(renderer, baseTexture, glTexture);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {\n      let flag = !0;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = !1;\n          break;\n        }\n      }\n      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n   */\n  static test(source) {\n    return typeof HTMLImageElement < \"u\" && (typeof source == \"string\" || source instanceof HTMLImageElement);\n  }\n}\nexport {\n  ImageResource\n};\n//# sourceMappingURL=ImageResource.mjs.map\n"],"names":["ImageResource","BaseImageResource","source","options","imageElement","settings","createBitmap","resolve","reject","completed","event","createImageBitmap","cors","r","blob","ALPHA_MODES","bitmap","renderer","baseTexture","glTexture","flag","glTextures","key","otherTex"],"mappings":";;;;AAGA,MAAMA,UAAsBC,EAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAU5C,YAAYC,GAAQC,GAAS;AAC3B,QAAIA,IAAUA,KAAW,CAAE,GAAE,OAAOD,KAAU,UAAU;AACtD,YAAME,IAAe,IAAI;AACzB,MAAAH,EAAkB,YAAYG,GAAcF,GAAQC,EAAQ,WAAW,GAAGC,EAAa,MAAMF,GAAQA,IAASE;AAAA,IAC/G;AACD,UAAMF,CAAM,GAAG,CAACA,EAAO,YAAY,KAAK,UAAU,KAAK,YAAY,KAAK,SAAS,GAAG,KAAK,UAAU,IAAI,KAAK,MAAMA,EAAO,KAAK,KAAK,WAAW,MAAM,KAAK,iBAAiB,IAAI,KAAK,gBAAgBC,EAAQ,gBAAgBE,EAAS,wBAAwB,CAAC,CAAC,WAAW,mBAAmB,KAAK,YAAY,OAAOF,EAAQ,aAAa,WAAWA,EAAQ,YAAY,MAAM,KAAK,SAAS,MAAM,KAAK,QAAQ,MAAMA,EAAQ,aAAa,MAAM,KAAK,KAAI;AAAA,EAC1b;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,KAAKG,GAAc;AACjB,WAAO,KAAK,QAAQ,KAAK,SAASA,MAAiB,WAAW,KAAK,eAAeA,IAAe,KAAK,QAAQ,IAAI,QAAQ,CAACC,GAASC,MAAW;AAC7I,YAAMN,IAAS,KAAK;AACpB,WAAK,MAAMA,EAAO;AAClB,YAAMO,IAAY,MAAM;AACtB,aAAK,cAAcP,EAAO,SAAS,MAAMA,EAAO,UAAU,MAAM,KAAK,UAAU,KAAK,QAAQ,MAAM,KAAK,eAAeK,EAAQ,KAAK,QAAO,CAAE,IAAIA,EAAQ,IAAI;AAAA,MACpK;AACM,MAAAL,EAAO,YAAYA,EAAO,MAAMO,EAAW,KAAIP,EAAO,SAASO,GAAWP,EAAO,UAAU,CAACQ,MAAU;AACpG,QAAAF,EAAOE,CAAK,GAAG,KAAK,QAAQ,KAAKA,CAAK;AAAA,MAC9C;AAAA,IACA,CAAK,GAAG,KAAK;AAAA,EACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,UAAU;AACR,UAAMR,IAAS,KAAK;AACpB,QAAI,KAAK,aAAa;AACpB,aAAO,KAAK;AACd,QAAI,KAAK,WAAW,QAAQ,CAAC,WAAW;AACtC,aAAO,QAAQ,QAAQ,IAAI;AAC7B,UAAMS,IAAoB,WAAW,mBAAmBC,IAAO,CAACV,EAAO,eAAeA,EAAO,gBAAgB;AAC7G,WAAO,KAAK,WAAW;AAAA,MACrBA,EAAO;AAAA,MACP;AAAA,QACE,MAAMU,IAAO,SAAS;AAAA,MACvB;AAAA,IACP,EAAM,KAAK,CAACC,MAAMA,EAAE,KAAI,CAAE,EAAE,KAAK,CAACC,MAASH;AAAA,MACrCG;AAAA,MACA;AAAA,MACA;AAAA,MACAZ,EAAO;AAAA,MACPA,EAAO;AAAA,MACP;AAAA,QACE,kBAAkB,KAAK,cAAc,QAAQ,KAAK,cAAca,EAAY,SAAS,gBAAgB;AAAA,MACtG;AAAA,IACF,CAAA,EAAE,KAAK,CAACC,MAAW,KAAK,YAAY,QAAQ,OAAQ,KAAI,KAAK,SAASA,GAAQ,KAAK,UAAU,KAAK,WAAW,MAAM,QAAQ,QAAQ,IAAI,EAAE,GAAG,KAAK;AAAA,EACnJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,OAAOC,GAAUC,GAAaC,GAAW;AACvC,QAAI,OAAO,KAAK,aAAa,aAAaD,EAAY,YAAY,KAAK,YAAY,CAAC,KAAK;AACvF,aAAO,MAAM,OAAOD,GAAUC,GAAaC,CAAS;AACtD,QAAI,CAAC,KAAK,WAAW,KAAK,WAAW,CAAC,KAAK;AACzC,aAAO;AACT,QAAI,MAAM,OAAOF,GAAUC,GAAaC,GAAW,KAAK,MAAM,GAAG,CAAC,KAAK,gBAAgB;AACrF,UAAIC,IAAO;AACX,YAAMC,IAAaH,EAAY;AAC/B,iBAAWI,KAAOD,GAAY;AAC5B,cAAME,IAAWF,EAAWC,CAAG;AAC/B,YAAIC,MAAaJ,KAAaI,EAAS,YAAYL,EAAY,SAAS;AACtE,UAAAE,IAAO;AACP;AAAA,QACD;AAAA,MACF;AACD,MAAAA,MAAS,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS,KAAK,SAAS;AAAA,IAClE;AACD,WAAO;AAAA,EACR;AAAA;AAAA,EAED,UAAU;AACR,SAAK,OAAO,SAAS,MAAM,KAAK,OAAO,UAAU,MAAM,MAAM,QAAS,GAAE,KAAK,WAAW,KAAK,OAAO,MAAK,GAAI,KAAK,SAAS,OAAO,KAAK,WAAW,MAAM,KAAK,QAAQ;AAAA,EACtK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,OAAO,KAAKlB,GAAQ;AAClB,WAAO,OAAO,mBAAmB,QAAQ,OAAOA,KAAU,YAAYA,aAAkB;AAAA,EACzF;AACH;","x_google_ignoreList":[0]}