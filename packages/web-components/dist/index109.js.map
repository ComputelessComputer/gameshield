{"version":3,"file":"index109.js","sources":["../../../node_modules/.pnpm/@pixi+graphics@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3__@pixi+sprit_3c40fa602f454a6b22dad0b27bc41147/node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs"],"sourcesContent":["import { Point, BatchGeometry, WRAP_MODES, BaseTexture, BatchDrawCall, BatchTextureArray, DRAW_MODES, Color } from \"@pixi/core\";\nimport { Bounds } from \"@pixi/display\";\nimport { GraphicsData } from \"./GraphicsData.mjs\";\nimport { DRAW_CALL_POOL, BATCH_POOL, FILL_COMMANDS } from \"./utils/index.mjs\";\nimport { BatchPart } from \"./utils/BatchPart.mjs\";\nimport { buildPoly } from \"./utils/buildPoly.mjs\";\nimport { buildLine } from \"./utils/buildLine.mjs\";\nconst tmpPoint = new Point(), _GraphicsGeometry = class _GraphicsGeometry2 extends BatchGeometry {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor() {\n    super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new Bounds(), this.boundsDirty = -1;\n  }\n  /**\n   * Get the current bounds of the graphic geometry.\n   *\n   * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n   * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n   * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n   * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n   * @readonly\n   */\n  get bounds() {\n    return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n  }\n  /** Call if you changed graphicsData manually. Empties all batch buffers. */\n  invalidate() {\n    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++)\n      this.drawCalls[i].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i]);\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset(), BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This GraphicsGeometry object. Good for chaining method calls\n   */\n  clear() {\n    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n  }\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - Defines style of the fill.\n   * @param lineStyle - Defines style of the lines.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    return this.graphicsData.push(data), this.dirty++, this;\n  }\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  drawHole(shape, matrix = null) {\n    if (!this.graphicsData.length)\n      return null;\n    const data = new GraphicsData(shape, null, null, matrix), lastShape = this.graphicsData[this.graphicsData.length - 1];\n    return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, this;\n  }\n  /** Destroys the GraphicsGeometry object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i)\n      this.graphicsData[i].destroy();\n    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {\n        let hitHole = !1;\n        if (data.holes) {\n          for (let i2 = 0; i2 < data.holes.length; i2++)\n            if (data.holes[i2].shape.contains(tmpPoint.x, tmpPoint.y)) {\n              hitHole = !0;\n              break;\n            }\n        }\n        if (!hitHole)\n          return !0;\n      }\n    }\n    return !1;\n  }\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   */\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = !0;\n      return;\n    }\n    if (!this.validateBatching())\n      return;\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs, graphicsData = this.graphicsData;\n    let batchPart = null, currentStyle = null;\n    this.batches.length > 0 && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i], fillStyle = data.fillStyle, lineStyle = data.lineStyle;\n      FILL_COMMANDS[data.type].build(data), data.matrix && this.transformPoints(data.points, data.matrix), (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible)\n          continue;\n        const nextTexture = style.texture.baseTexture, index2 = this.indices.length, attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT, j === 0 ? this.processFill(data) : this.processLine(data);\n        const size = this.points.length / 2 - attribIndex;\n        size !== 0 && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = BATCH_POOL.pop() || new BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix));\n      }\n    }\n    const index = this.indices.length, attrib = this.points.length / 2;\n    if (batchPart && batchPart.end(index, attrib), this.batches.length === 0) {\n      this.batchable = !0;\n      return;\n    }\n    const need32 = attrib > 65535;\n    this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n  }\n  /**\n   * Affinity check\n   * @param styleA\n   * @param styleB\n   */\n  _compareStyles(styleA, styleB) {\n    return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);\n  }\n  /** Test geometry for batching process. */\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n      return !1;\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i], fill = data.fillStyle, line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid || line && !line.texture.baseTexture.valid)\n        return !1;\n    }\n    return !0;\n  }\n  /** Offset the indices so that it works with the batcher. */\n  packBatches() {\n    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   */\n  isBatchable() {\n    if (this.points.length > 65535 * 2)\n      return !1;\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++)\n      if (batches[i].style.native)\n        return !1;\n    return this.points.length < _GraphicsGeometry2.BATCHABLE_SIZE * 2;\n  }\n  /** Converts intermediate batches data to drawCalls. */\n  buildDrawCalls() {\n    let TICK = ++BaseTexture._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++)\n      this.drawCalls[i].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i]);\n    this.drawCalls.length = 0;\n    const colors = this.colors, textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), currentGroup.texArray.count = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = DRAW_MODES.TRIANGLES;\n    let textureCount = 0, currentTexture = null, textureId = 0, native = !1, drawMode = DRAW_MODES.TRIANGLES, index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i], maxTextures = 8, style = data.style, nextTexture = style.texture.baseTexture;\n      native !== !!style.native && (native = !!style.native, drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = maxTextures, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture, nextTexture._batchEnabled !== TICK && (textureCount === maxTextures && (TICK++, textureCount = 0, currentGroup.size > 0 && (currentGroup = DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._batchLocation = textureCount, nextTexture.wrapMode = WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture, textureCount++)), currentGroup.size += data.size, index += data.size, textureId = nextTexture._batchLocation, this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart), this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK, this.packAttributes();\n  }\n  /** Packs attributes to single buffer. */\n  packAttributes() {\n    const verts = this.points, uvs = this.uvs, colors = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(verts.length * 3 * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++)\n      f32[p++] = verts[i * 2], f32[p++] = verts[i * 2 + 1], f32[p++] = uvs[i * 2], f32[p++] = uvs[i * 2 + 1], u32[p++] = colors[i], f32[p++] = textureIds[i];\n    this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16);\n  }\n  /**\n   * Process fill part of Graphics.\n   * @param data\n   */\n  processFill(data) {\n    data.holes.length ? buildPoly.triangulate(data, this) : FILL_COMMANDS[data.type].triangulate(data, this);\n  }\n  /**\n   * Process line part of Graphics.\n   * @param data\n   */\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++)\n      buildLine(data.holes[i], this);\n  }\n  /**\n   * Process the holes data.\n   * @param holes\n   */\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      FILL_COMMANDS[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix);\n    }\n  }\n  /** Update the local bounds of the object. Expensive to use performance-wise. */\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear(), bounds.addVertexData(this.points, 0, this.points.length), bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  /**\n   * Transform points using matrix.\n   * @param points - Points to transform\n   * @param matrix - Transform matrix\n   */\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2], y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx, points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  /**\n   * Add colors.\n   * @param colors - List of colors to add to\n   * @param color - Color to add\n   * @param alpha - Alpha to use\n   * @param size - Number of colors to add\n   * @param offset\n   */\n  addColors(colors, color, alpha, size, offset = 0) {\n    const bgr = Color.shared.setValue(color).toLittleEndianNumber(), result = Color.shared.setValue(bgr).toPremultiplied(alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++)\n      colors[offset + i] = result;\n  }\n  /**\n   * Add texture id that the shader/fragment wants to use.\n   * @param textureIds\n   * @param id\n   * @param size\n   * @param offset\n   */\n  addTextureIds(textureIds, id, size, offset = 0) {\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++)\n      textureIds[offset + i] = id;\n  }\n  /**\n   * Generates the UVs for a shape.\n   * @param verts - Vertices\n   * @param uvs - UVs\n   * @param texture - Reference to Texture\n   * @param start - Index buffer start index.\n   * @param size - The size/length for index buffer.\n   * @param matrix - Optional transform for all points.\n   */\n  addUvs(verts, uvs, texture, start, size, matrix = null) {\n    let index = 0;\n    const uvsStart = uvs.length, frame = texture.frame;\n    for (; index < size; ) {\n      let x = verts[(start + index) * 2], y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty, x = nx;\n      }\n      index++, uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size);\n  }\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   * @param uvs - array\n   * @param texture - region\n   * @param start - starting index for uvs\n   * @param size - how many points to adjust\n   */\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture, eps = 1e-6, finish = start + size * 2, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + eps), minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2)\n      minX = Math.min(minX, Math.floor(uvs[i] + eps)), minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    offsetX -= minX, offsetY -= minY;\n    for (let i = start; i < finish; i += 2)\n      uvs[i] = (uvs[i] + offsetX) * scaleX, uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n  }\n};\n_GraphicsGeometry.BATCHABLE_SIZE = 100;\nlet GraphicsGeometry = _GraphicsGeometry;\nexport {\n  GraphicsGeometry\n};\n//# sourceMappingURL=GraphicsGeometry.mjs.map\n"],"names":["tmpPoint","Point","_GraphicsGeometry","_GraphicsGeometry2","BatchGeometry","Bounds","i","DRAW_CALL_POOL","batchPart","BATCH_POOL","shape","fillStyle","lineStyle","matrix","data","GraphicsData","lastShape","point","graphicsData","hitHole","i2","uvs","currentStyle","FILL_COMMANDS","j","style","nextTexture","index2","attribIndex","WRAP_MODES","size","BatchPart","index","attrib","need32","styleA","styleB","l","fill","line","batches","batch","TICK","BaseTexture","colors","textureIds","currentGroup","BatchDrawCall","BatchTextureArray","DRAW_MODES","textureCount","currentTexture","textureId","native","drawMode","maxTextures","verts","glPoints","f32","u32","p","buildPoly","buildLine","holes","hole","bounds","points","x","y","color","alpha","offset","bgr","Color","result","id","texture","start","uvsStart","frame","nx","baseTexture","eps","finish","scaleX","scaleY","offsetX","offsetY","minX","minY","GraphicsGeometry"],"mappings":"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","x_google_ignoreList":[0]}