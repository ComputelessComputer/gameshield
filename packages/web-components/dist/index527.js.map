{"version":3,"file":"index527.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"],"sourcesContent":["\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n"],"names":["roundedShapeArc","g","points","radius","vecFrom","p","pp","x","y","len","nx","ny","sharpCorner","i","p1","p2","pRadius","p3","v1","v2","angle","radDirection","drawDirection","halfAngle","cRadius","lenOut","cX","cY","startAngle","endAngle","roundedShapeQuadraticCurve","smoothness","distance","pointLerp","t","numPoints","thisPoint","lastPoint","nextPoint","lastEdgeLength","start","lastOffsetDistance","nextEdgeLength","end","nextOffsetDistance"],"mappings":"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","x_google_ignoreList":[0]}