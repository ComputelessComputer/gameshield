{"version":3,"file":"index19.js","sources":["../../../node_modules/.pnpm/@pixi+assets@7.4.3_@pixi+core@7.4.3/node_modules/@pixi/assets/lib/Assets.mjs"],"sourcesContent":["import { utils, extensions, ExtensionType } from \"@pixi/core\";\nimport { BackgroundLoader } from \"./BackgroundLoader.mjs\";\nimport { Cache } from \"./cache/Cache.mjs\";\nimport { Loader } from \"./loader/Loader.mjs\";\nimport \"./loader/parsers/index.mjs\";\nimport { Resolver } from \"./resolver/Resolver.mjs\";\nimport { convertToList } from \"./utils/convertToList.mjs\";\nimport { isSingleItem } from \"./utils/isSingleItem.mjs\";\nimport { loadTextures } from \"./loader/parsers/textures/loadTextures.mjs\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [], this._initialized = !1, this.resolver = new Resolver(), this.loader = new Loader(), this.cache = Cache, this._backgroundLoader = new BackgroundLoader(this.loader), this._backgroundLoader.active = !0, this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Asset manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      console.warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    if (this._initialized = !0, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {\n      let manifest = options.manifest;\n      typeof manifest == \"string\" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == \"number\" ? [resolutionPref] : resolutionPref, formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    }), options.preferences && this.setPreferences(options.preferences);\n  }\n  add(aliases, srcs, data, format, loadParser) {\n    this.resolver.add(aliases, srcs, data, format, loadParser);\n  }\n  async load(urls, onProgress) {\n    this._initialized || await this.init();\n    const singleAsset = isSingleItem(urls), urlArray = convertToList(urls).map((url) => {\n      if (typeof url != \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url), Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      return this.resolver.hasKey(url) || this.add({ alias: url, src: url }), url;\n    }), resolveResults = this.resolver.resolve(urlArray), out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    this._initialized || await this.init();\n    let singleAsset = !1;\n    typeof bundleIds == \"string\" && (singleAsset = !0, bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), out = {}, keys = Object.keys(resolveResults);\n    let count = 0, total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    }, promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    this._initialized || await this.init(), typeof urls == \"string\" && (urls = [urls]);\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    this._initialized || await this.init(), typeof bundleIds == \"string\" && (bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;\n  }\n  get(keys) {\n    if (typeof keys == \"string\")\n      return Cache.get(keys);\n    const assets = {};\n    for (let i = 0; i < keys.length; i++)\n      assets[i] = Cache.get(keys[i]);\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);\n    this._backgroundLoader.active = !1;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = !0;\n    const out = {};\n    return resolveArray.forEach((resolveResult, i) => {\n      const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];\n      resolveResult.alias && keys.push(...resolveResult.alias), out[resolveKeys[i]] = asset, Cache.set(keys, asset);\n    }), out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    this._initialized || await this.init();\n    const urlArray = convertToList(urls).map((url) => typeof url != \"string\" ? url.src : url), resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    this._initialized || await this.init(), bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    }), await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);\n    for (const detection of options.detections)\n      options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));\n    return formats = formats.filter((format, index) => formats.indexOf(format) === index), formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * @deprecated since 7.2.0\n   * @see {@link Assets.setPreferences}\n   */\n  get preferWorkers() {\n    return loadTextures.config.preferWorkers;\n  }\n  set preferWorkers(value) {\n    utils.deprecation(\"7.2.0\", \"Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.\"), this.setPreferences({ preferWorkers: value });\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nexport {\n  Assets,\n  AssetsClass\n};\n//# sourceMappingURL=Assets.mjs.map\n"],"names":["AssetsClass","Resolver","Loader","Cache","BackgroundLoader","options","manifest","resolutionPref","_a","resolution","formats","_b","aliases","srcs","data","format","loadParser","urls","onProgress","singleAsset","isSingleItem","urlArray","convertToList","url","alias","resolveResults","out","bundleId","assets","bundleIds","keys","count","total","_onProgress","promises","resolveResult","resolveResult2","i","resolveArray","resolveKeys","loadedAssets","asset","detection","index","loadTextures","value","utils.deprecation","preferences","parser","key","Assets","extensions","ExtensionType"],"mappings":"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","x_google_ignoreList":[0]}