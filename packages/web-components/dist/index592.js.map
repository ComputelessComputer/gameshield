{"version":3,"file":"index592.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"],"sourcesContent":["import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { nextPow2 } from '../../../maths/misc/pow2.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = nextPow2(width);\n    height = nextPow2(height);\n    return { width, height };\n  }\n  getTexture(options, resolution, style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style,\n        resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(\n      options\n    );\n    this._renderer.texture.initSource(texture._source);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  createTextureAndCanvas(options) {\n    const { text, style } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    return { texture, canvasAndContext };\n  }\n  getManagedTexture(text) {\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    const textKey = text._getKey();\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture);\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n      this.returnTexture(activeTexture.texture);\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.textBaseline = style.textBaseline;\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured) : null;\n        if (style._stroke?.width) {\n          const padding = style._stroke.width * style._stroke.alignment;\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, padding);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n"],"names":["CanvasTextSystem","_renderer","text","resolution","style","measured","CanvasTextMetrics","width","height","nextPow2","options","_textKey","deprecation","TextStyle","texture","canvasAndContext","CanvasPool","canvas","getPo2TextureFromSource","trimmed","getCanvasBoundingBox","textKey","source","TexturePool","activeTexture","context","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","_a","strokeStyle","linePositionX","linePositionY","passesCount","i","isShadowPass","dsOffsetText","dsOffsetShadow","shadowOptions","dropShadowColor","dropShadowAlpha","Color","dropShadowBlur","dropShadowDistance","getCanvasFillStyle","_b","padding","linePositionYShift","strokeWidth","_c","i2","_d","x","y","isStroke","letterSpacing","useExperimentalLetterSpacing","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","j","ExtensionType"],"mappings":"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","x_google_ignoreList":[0]}