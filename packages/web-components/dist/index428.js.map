{"version":3,"file":"index428.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"],"sourcesContent":["\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n"],"names":["textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","i","generateSampleSrc","generateTextureBatchBit","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl"],"mappings":"AACA,MAAMA,IAA0B,CAAA;AAChC,SAASC,EAAmBC,GAAa;AACvC,QAAMC,IAAM,CAAA;AACZ,MAAID,MAAgB;AAClB,IAAAC,EAAI,KAAK,4DAA4D,GACrEA,EAAI,KAAK,qDAAqD;AAAA,OACzD;AACL,QAAIC,IAAe;AACnB,aAASC,IAAI,GAAGA,IAAIH,GAAaG;AAC/B,MAAAF,EAAI,KAAK,sBAAsBC,GAAc,sBAAsBC,IAAI,CAAC,oBAAoB,GAC5FF,EAAI,KAAK,sBAAsBC,GAAc,uBAAuBC,IAAI,CAAC,YAAY;AAAA,EAExF;AACD,SAAOF,EAAI,KAAK;AAAA,CAAI;AACtB;AACA,SAASG,EAAkBJ,GAAa;AACtC,QAAMC,IAAM,CAAA;AACZ,MAAID,MAAgB;AAClB,IAAAC,EAAI,KAAK,iFAAiF;AAAA,OACrF;AACL,IAAAA,EAAI,KAAK,qBAAqB;AAC9B,aAASE,IAAI,GAAGA,IAAIH,GAAaG;AAC/B,MAAIA,MAAMH,IAAc,IACtBC,EAAI,KAAK,aAAa,IAEtBA,EAAI,KAAK,UAAUE,CAAC,IAAI,GAE1BF,EAAI,KAAK,mDAAmDE,IAAI,CAAC,mBAAmBA,IAAI,CAAC,qBAAqB,GAC9GF,EAAI,KAAK,eAAe;AAE1B,IAAAA,EAAI,KAAK,GAAG;AAAA,EACb;AACD,SAAOA,EAAI,KAAK;AAAA,CAAI;AACtB;AACA,SAASI,EAAwBL,GAAa;AAC5C,SAAKF,EAAwBE,CAAW,MACtCF,EAAwBE,CAAW,IAAI;AAAA,IACrC,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIR,MAAM;AAAA;AAAA;AAAA,MAGN,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMN;AAAA,IACD,UAAU;AAAA,MACR,QAAQ;AAAA;AAAA;AAAA,kBAGED,EAAmBC,CAAW,CAAC;AAAA;AAAA,MAEzC,MAAM;AAAA;AAAA;AAAA;AAAA,kBAIII,EAAkBJ,CAAW,CAAC;AAAA;AAAA,IAEzC;AAAA,EACP,IAESF,EAAwBE,CAAW;AAC5C;AACA,MAAMM,IAAyB,CAAA;AAC/B,SAASC,EAAoBP,GAAa;AACxC,QAAMC,IAAM,CAAA;AACZ,WAASE,IAAI,GAAGA,IAAIH,GAAaG;AAC/B,IAAIA,IAAI,KACNF,EAAI,KAAK,MAAM,GAEbE,IAAIH,IAAc,KACpBC,EAAI,KAAK,mBAAmBE,CAAC,KAAK,GAEpCF,EAAI,KAAK,GAAG,GACZA,EAAI,KAAK,iCAAiCE,CAAC,UAAU,GACrDF,EAAI,KAAK,GAAG;AAEd,SAAOA,EAAI,KAAK;AAAA,CAAI;AACtB;AACA,SAASO,EAA0BR,GAAa;AAC9C,SAAKM,EAAuBN,CAAW,MACrCM,EAAuBN,CAAW,IAAI;AAAA,IACpC,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,MAKR,MAAM;AAAA;AAAA;AAAA,MAGN,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMN;AAAA,IACD,UAAU;AAAA,MACR,QAAQ;AAAA;AAAA;AAAA,8CAG8BA,CAAW;AAAA;AAAA;AAAA,MAGjD,MAAM;AAAA;AAAA,kBAEIO,EAAoBP,CAAW,CAAC;AAAA;AAAA,IAE3C;AAAA,EACP,IAESM,EAAuBN,CAAW;AAC3C;","x_google_ignoreList":[0]}