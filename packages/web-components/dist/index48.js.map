{"version":3,"file":"index48.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/batch/BatchRenderer.mjs"],"sourcesContent":["import { Color } from \"@pixi/color\";\nimport { ENV } from \"@pixi/constants\";\nimport { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { settings } from \"@pixi/settings\";\nimport { deprecation, premultiplyBlendMode, nextPow2, log2 } from \"@pixi/utils\";\nimport { ViewableBuffer } from \"../geometry/ViewableBuffer.mjs\";\nimport { checkMaxIfStatementsInShader } from \"../shader/utils/checkMaxIfStatementsInShader.mjs\";\nimport { State } from \"../state/State.mjs\";\nimport { BaseTexture } from \"../textures/BaseTexture.mjs\";\nimport { BatchDrawCall } from \"./BatchDrawCall.mjs\";\nimport { BatchGeometry } from \"./BatchGeometry.mjs\";\nimport { BatchShaderGenerator } from \"./BatchShaderGenerator.mjs\";\nimport { BatchTextureArray } from \"./BatchTextureArray.mjs\";\nimport { canUploadSameBuffer } from \"./canUploadSameBuffer.mjs\";\nimport { maxRecommendedTextures } from \"./maxRecommendedTextures.mjs\";\nimport { ObjectRenderer } from \"./ObjectRenderer.mjs\";\nimport defaultFragment from \"./texture.frag.mjs\";\nimport defaultVertex from \"./texture.vert.mjs\";\nconst _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer {\n  /**\n   * This will hook onto the renderer's `contextChange`\n   * and `prerender` signals.\n   * @param {PIXI.Renderer} renderer - The renderer this works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry, this.vertexSize = 6, this.state = State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on(\"prerender\", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];\n  }\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @default 32\n   */\n  static get defaultMaxTextures() {\n    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32), this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   */\n  static get canUploadSameBuffer() {\n    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer(), this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  /**\n   * @see PIXI.BatchRenderer#maxTextures\n   * @deprecated since 7.1.0\n   * @readonly\n   */\n  get MAX_TEXTURES() {\n    return deprecation(\"7.1.0\", \"BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures\"), this.maxTextures;\n  }\n  /**\n   * The default vertex shader source\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  /**\n   * The default fragment shader source\n   * @readonly\n   */\n  static get defaultFragmentTemplate() {\n    return defaultFragment;\n  }\n  /**\n   * Set the shader generator.\n   * @param {object} [options]\n   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n   */\n  setShaderGenerator({\n    vertex = _BatchRenderer2.defaultVertexSrc,\n    fragment = _BatchRenderer2.defaultFragmentTemplate\n  } = {}) {\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  /**\n   * Handles the `contextChange` signal.\n   *\n   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.\n   */\n  contextChange() {\n    const gl = this.renderer.gl;\n    settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(\n      gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n      _BatchRenderer2.defaultMaxTextures\n    ), this.maxTextures = checkMaxIfStatementsInShader(\n      this.maxTextures,\n      gl\n    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] = new this.geometryClass();\n    this.initFlushBuffers();\n  }\n  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    for (; _drawCallPool.length < MAX_SPRITES; )\n      _drawCallPool.push(new BatchDrawCall());\n    for (; _textureArrayPool.length < MAX_TA; )\n      _textureArrayPool.push(new BatchTextureArray());\n    for (let i = 0; i < this.maxTextures; i++)\n      this._tempBoundTextures[i] = null;\n  }\n  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n  onPrerender() {\n    this._flushId = 0;\n  }\n  /**\n   * Buffers the \"batchable\" object. It need not be rendered immediately.\n   * @param {PIXI.DisplayObject} element - the element to render when\n   *    using this renderer\n   */\n  render(element) {\n    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i), start = i, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);\n    }\n    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);\n    for (let i = 0; i < boundTextures.length; i++)\n      boundTextures[i] = null;\n    BaseTexture._globalBatch = TICK;\n  }\n  /**\n   * Populating drawcalls for rendering\n   * @param texArray\n   * @param start\n   * @param finish\n   */\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this, drawCalls = _BatchRenderer2._drawCallPool;\n    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex, drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i], tex = sprite._texture.baseTexture, spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null, start < i && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;\n    }\n    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;\n  }\n  /**\n   * Bind textures for current rendering\n   * @param texArray\n   */\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++)\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]), texArray.elements[j] = null;\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const { texArray, type, size, start, blend } = drawCalls[i];\n      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  /** Renders the content _now_ and empties the current batch. */\n  flush() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }\n  /** Starts a new sprite batch. */\n  start() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }\n  /** Stops and flushes the current batch. */\n  stop() {\n    this.flush();\n  }\n  /** Destroys this `BatchRenderer`. It cannot be used again. */\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] && this._packedGeometries[i].destroy();\n    this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();\n  }\n  /**\n   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n   * @param size - minimum capacity required\n   * @returns - buffer than can hold atleast `size` floats\n   */\n  getAttributeBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 8)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 8;\n    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._aBuffers[roundedSize];\n    return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;\n  }\n  /**\n   * Fetches an index buffer from `this._iBuffers` that can\n   * have at least `size` capacity.\n   * @param size - minimum required capacity\n   * @returns - buffer that can fit `size` indices.\n   */\n  getIndexBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 12)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 12;\n    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._iBuffers[roundedSizeIndex];\n    return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;\n  }\n  /**\n   * Takes the four batching parameters of `element`, interleaves\n   * and pushes them into the batching attribute/index buffers given.\n   *\n   * It uses these properties: `vertexData` `uvs`, `textureId` and\n   * `indicies`. It also uses the \"tint\" of the base-texture, if\n   * present.\n   * @param {PIXI.DisplayObject} element - element being rendered\n   * @param attributeBuffer - attribute buffer.\n   * @param indexBuffer - index buffer\n   * @param aIndex - number of floats already in the attribute buffer\n   * @param iIndex - number of indices already in `indexBuffer`\n   */\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n    for (let i = 0; i < vertexData.length; i += 2)\n      float32View[aIndex++] = vertexData[i], float32View[aIndex++] = vertexData[i + 1], float32View[aIndex++] = uvs[i], float32View[aIndex++] = uvs[i + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;\n    for (let i = 0; i < indicies.length; i++)\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n  }\n};\n_BatchRenderer.defaultBatchSize = 4096, /** @ignore */\n_BatchRenderer.extension = {\n  name: \"batch\",\n  type: ExtensionType.RendererPlugin\n}, /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create \"batches\" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n* @member {PIXI.BatchDrawCall[]}\n*/\n_BatchRenderer._drawCallPool = [], /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create \"batches\" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n* @member {PIXI.BatchTextureArray[]}\n*/\n_BatchRenderer._textureArrayPool = [];\nlet BatchRenderer = _BatchRenderer;\nextensions.add(BatchRenderer);\nexport {\n  BatchRenderer\n};\n//# sourceMappingURL=BatchRenderer.mjs.map\n"],"names":["_BatchRenderer","_BatchRenderer2","ObjectRenderer","renderer","BatchGeometry","State","maxRecommendedTextures","value","canUploadSameBuffer","deprecation","defaultVertex","defaultFragment","vertex","fragment","BatchShaderGenerator","gl","settings","ENV","checkMaxIfStatementsInShader","i","_drawCallPool","_textureArrayPool","MAX_SPRITES","MAX_TA","BatchDrawCall","BatchTextureArray","element","textures","maxTextures","textureArrays","batch","boundTextures","touch","TICK","BaseTexture","countTexArrays","texArray","start","tex","finish","elements","_attributeBuffer","_indexBuffer","vertexSize","drawCalls","dcIndex","aIndex","iIndex","drawCall","sprite","spriteBlendMode","premultiplyBlendMode","textureSystem","j","packedGeometries","attributeBuffer","indexBuffer","dcCount","stateSystem","curTexArray","type","size","blend","roundedP2","nextPow2","roundedSizeIndex","log2","roundedSize","buffer","ViewableBuffer","uint32View","float32View","packedVertices","uvs","indicies","vertexData","textureId","alpha","argb","Color","ExtensionType","BatchRenderer","extensions"],"mappings":"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","x_google_ignoreList":[0]}