{"version":3,"file":"index392.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/filters/FilterSystem.mjs"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? colorTextureSource._resolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = colorTextureSource.antialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      const viewPort = renderer.renderTarget.rootViewPort;\n      const rootResolution = renderer.renderTarget.renderTarget.resolution;\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad(padding | 0);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n"],"names":["quadGeometry","Geometry","FilterSystem","renderer","UniformGroup","BindGroup","_a","instruction","filters","filterData","bounds","getGlobalRenderableBounds","filterFrameTransform","colorTextureSource","resolution","padding","antialias","blendRequired","enabled","clipToViewport","i","filter","warn","viewPort","rootResolution","TexturePool","inputTexture","backTexture","Texture","previousBounds","renderTarget","flip","flop","t","lastRenderSurface","backgroundResolution","x","y","width","height","input","output","clear","offset","Point","isFinalTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","rootTexture","batchUniforms","RendererType","Bounds","outputMatrix","sprite","data","mappedMatrix","worldTransform","Matrix","renderGroup","ExtensionType"],"mappings":"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","x_google_ignoreList":[0]}