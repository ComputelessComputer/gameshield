{"version":3,"file":"index536.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"],"sourcesContent":["\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n"],"names":["BatchableMesh","value","uvBuffer","uvs","transformedUvs","textureMatrix"],"mappings":"AACA,MAAMA,EAAc;AAAA,EAClB,cAAc;AACZ,SAAK,cAAc,WACnB,KAAK,aAAa,IAClB,KAAK,cAAc,GACnB,KAAK,kBAAkB,GACvB,KAAK,cAAc,GACnB,KAAK,WAAW,MAChB,KAAK,SAAS,MACd,KAAK,yBAAyB,IAC9B,KAAK,cAAc;AAAA,EACpB;AAAA,EACD,IAAI,YAAY;AACd,WAAO,KAAK,WAAW;AAAA,EACxB;AAAA,EACD,IAAI,WAAW;AACb,WAAO,KAAK,aAAa,KAAK,SAAS;AAAA,EACxC;AAAA,EACD,IAAI,SAASC,GAAO;AAClB,SAAK,YAAYA;AAAA,EAClB;AAAA,EACD,QAAQ;AACN,SAAK,aAAa,MAClB,KAAK,UAAU,MACf,KAAK,WAAW,MAChB,KAAK,SAAS,MACd,KAAK,WAAW,MAChB,KAAK,cAAc,IACnB,KAAK,yBAAyB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,WAAWA,GAAO;AAChB,IAAI,KAAK,YAAYA,MAErB,KAAK,UAAUA,GACf,KAAK,yBAAyB;AAAA,EAC/B;AAAA,EACD,IAAI,MAAM;AAER,UAAMC,IADW,KAAK,SACI,UAAU,KAAK,GACnCC,IAAMD,EAAS;AACrB,QAAIE,IAAiBD;AACrB,UAAME,IAAgB,KAAK,QAAQ;AACnC,WAAKA,EAAc,aACjBD,IAAiB,KAAK,kBAClB,KAAK,2BAA2BC,EAAc,aAAa,KAAK,gBAAgBH,EAAS,gBACvF,CAACE,KAAkBA,EAAe,SAASD,EAAI,YACjDC,IAAiB,KAAK,kBAAkB,IAAI,aAAaD,EAAI,MAAM,IAErE,KAAK,yBAAyBE,EAAc,WAC5C,KAAK,cAAcH,EAAS,WAC5BG,EAAc,YAAYF,GAAKC,CAAc,KAG1CA;AAAA,EACR;AAAA,EACD,IAAI,YAAY;AACd,WAAO,KAAK,SAAS;AAAA,EACtB;AAAA,EACD,IAAI,UAAU;AACZ,WAAO,KAAK,SAAS;AAAA,EACtB;AAAA,EACD,IAAI,QAAQ;AACV,WAAO,KAAK,WAAW;AAAA,EACxB;AAAA,EACD,IAAI,iBAAiB;AACnB,WAAO,KAAK,WAAW;AAAA,EACxB;AAAA,EACD,IAAI,gBAAgB;AAClB,WAAO,KAAK,SAAS,UAAU,SAAS;AAAA,EACzC;AAAA,EACD,IAAI,YAAY;AACd,WAAO,KAAK,SAAS,QAAQ;AAAA,EAC9B;AACH;","x_google_ignoreList":[0]}