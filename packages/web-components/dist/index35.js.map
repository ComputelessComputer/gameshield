{"version":3,"file":"index35.js","sources":["../../../node_modules/.pnpm/@pixi+ticker@7.4.3/node_modules/@pixi/ticker/lib/Ticker.mjs"],"sourcesContent":["import { UPDATE_PRIORITY } from \"./const.mjs\";\nimport { TickerListener } from \"./TickerListener.mjs\";\nconst _Ticker = class _Ticker2 {\n  constructor() {\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {\n      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, !0));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next, previous = this._head;\n    if (!current)\n      listener.connect(previous);\n    else {\n      for (; current; ) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current, current = current.next;\n      }\n      listener.previous || listener.connect(previous);\n    }\n    return this._startIfPossible(), this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    for (; listener; )\n      listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head)\n      return 0;\n    let count = 0, current = this._head;\n    for (; current = current.next; )\n      count++;\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      for (; listener; )\n        listener = listener.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link PIXI.Ticker#elapsedMS},\n   * the current {@link PIXI.Ticker#deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link PIXI.Ticker#lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS)\n          return;\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      for (; listener; )\n        listener = listener.emit(this.deltaTime);\n      head.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.Ticker#deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This value is used to cap {@link PIXI.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0)\n      this._minElapsedMS = 0;\n    else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n   * {@link PIXI.VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the PIXI.Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker2._shared) {\n      const shared = _Ticker2._shared = new _Ticker2();\n      shared.autoStart = !0, shared._protected = !0;\n    }\n    return _Ticker2._shared;\n  }\n  /**\n   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get system() {\n    if (!_Ticker2._system) {\n      const system = _Ticker2._system = new _Ticker2();\n      system.autoStart = !0, system._protected = !0;\n    }\n    return _Ticker2._system;\n  }\n};\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\nexport {\n  Ticker\n};\n//# sourceMappingURL=Ticker.mjs.map\n"],"names":["_Ticker","_Ticker2","TickerListener","time","fn","context","priority","UPDATE_PRIORITY","listener","current","previous","count","currentTime","elapsedMS","delta","head","fps","minFPS","minFPMS","maxFPS","shared","system","Ticker"],"mappings":";;AAEA,MAAMA,IAAU,MAAMC,EAAS;AAAA,EAC7B,cAAc;AACZ,SAAK,YAAY,IAAI,KAAK,YAAY,GAAG,KAAK,WAAW,IAAI,KAAK,QAAQ,GAAG,KAAK,UAAU,IAAI,KAAK,aAAa,MAAM,KAAK,gBAAgB,KAAK,KAAK,gBAAgB,GAAG,KAAK,aAAa,IAAI,KAAK,aAAa,IAAI,KAAK,QAAQ,IAAIC,EAAe,MAAM,MAAM,IAAI,CAAC,GAAG,KAAK,UAAU,IAAID,EAAS,YAAY,KAAK,YAAY,IAAIA,EAAS,YAAY,KAAK,QAAQ,CAACE,MAAS;AACjX,WAAK,aAAa,MAAM,KAAK,YAAY,KAAK,OAAOA,CAAI,GAAG,KAAK,WAAW,KAAK,eAAe,QAAQ,KAAK,MAAM,SAAS,KAAK,aAAa,sBAAsB,KAAK,KAAK;AAAA,IACpL;AAAA,EACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,mBAAmB;AACjB,SAAK,eAAe,QAAQ,KAAK,MAAM,SAAS,KAAK,WAAW,YAAY,IAAG,GAAI,KAAK,aAAa,KAAK,UAAU,KAAK,aAAa,sBAAsB,KAAK,KAAK;AAAA,EACvK;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,kBAAkB;AAChB,SAAK,eAAe,SAAS,qBAAqB,KAAK,UAAU,GAAG,KAAK,aAAa;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,mBAAmB;AACjB,SAAK,UAAU,KAAK,iBAAgB,IAAK,KAAK,aAAa,KAAK;EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,IAAIC,GAAIC,GAASC,IAAWC,EAAgB,QAAQ;AAClD,WAAO,KAAK,aAAa,IAAIL,EAAeE,GAAIC,GAASC,CAAQ,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,QAAQF,GAAIC,GAASC,IAAWC,EAAgB,QAAQ;AACtD,WAAO,KAAK,aAAa,IAAIL,EAAeE,GAAIC,GAASC,GAAU,EAAE,CAAC;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,aAAaE,GAAU;AACrB,QAAIC,IAAU,KAAK,MAAM,MAAMC,IAAW,KAAK;AAC/C,QAAI,CAACD;AACH,MAAAD,EAAS,QAAQE,CAAQ;AAAA,SACtB;AACH,aAAOD,KAAW;AAChB,YAAID,EAAS,WAAWC,EAAQ,UAAU;AACxC,UAAAD,EAAS,QAAQE,CAAQ;AACzB;AAAA,QACD;AACD,QAAAA,IAAWD,GAASA,IAAUA,EAAQ;AAAA,MACvC;AACD,MAAAD,EAAS,YAAYA,EAAS,QAAQE,CAAQ;AAAA,IAC/C;AACD,WAAO,KAAK,iBAAkB,GAAE;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,OAAON,GAAIC,GAAS;AAClB,QAAIG,IAAW,KAAK,MAAM;AAC1B,WAAOA;AACL,MAAAA,EAAS,MAAMJ,GAAIC,CAAO,IAAIG,IAAWA,EAAS,QAAS,IAAGA,IAAWA,EAAS;AACpF,WAAO,KAAK,MAAM,QAAQ,KAAK,gBAAiB,GAAE;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,IAAI,QAAQ;AACV,QAAI,CAAC,KAAK;AACR,aAAO;AACT,QAAIG,IAAQ,GAAGF,IAAU,KAAK;AAC9B,WAAOA,IAAUA,EAAQ;AACvB,MAAAE;AACF,WAAOA;AAAA,EACR;AAAA;AAAA,EAED,QAAQ;AACN,SAAK,YAAY,KAAK,UAAU,IAAI,KAAK,iBAAgB;AAAA,EAC1D;AAAA;AAAA,EAED,OAAO;AACL,SAAK,YAAY,KAAK,UAAU,IAAI,KAAK,gBAAe;AAAA,EACzD;AAAA;AAAA,EAED,UAAU;AACR,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,KAAI;AACT,UAAIH,IAAW,KAAK,MAAM;AAC1B,aAAOA;AACL,QAAAA,IAAWA,EAAS,QAAQ,EAAE;AAChC,WAAK,MAAM,QAAO,GAAI,KAAK,QAAQ;AAAA,IACpC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaD,OAAOI,IAAc,YAAY,OAAO;AACtC,QAAIC;AACJ,QAAID,IAAc,KAAK,UAAU;AAC/B,UAAIC,IAAY,KAAK,YAAYD,IAAc,KAAK,UAAUC,IAAY,KAAK,kBAAkBA,IAAY,KAAK,gBAAgBA,KAAa,KAAK,OAAO,KAAK,eAAe;AAC7K,cAAMC,IAAQF,IAAc,KAAK,aAAa;AAC9C,YAAIE,IAAQ,KAAK;AACf;AACF,aAAK,aAAaF,IAAcE,IAAQ,KAAK;AAAA,MAC9C;AACD,WAAK,UAAUD,GAAW,KAAK,YAAY,KAAK,UAAUZ,EAAS;AACnE,YAAMc,IAAO,KAAK;AAClB,UAAIP,IAAWO,EAAK;AACpB,aAAOP;AACL,QAAAA,IAAWA,EAAS,KAAK,KAAK,SAAS;AACzC,MAAAO,EAAK,QAAQ,KAAK;IACnB;AACC,WAAK,YAAY,KAAK,UAAU,KAAK,YAAY;AACnD,SAAK,WAAWH;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,IAAI,MAAM;AACR,WAAO,MAAM,KAAK;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWD,IAAI,SAAS;AACX,WAAO,MAAM,KAAK;AAAA,EACnB;AAAA,EACD,IAAI,OAAOI,GAAK;AACd,UAAMC,IAAS,KAAK,IAAI,KAAK,QAAQD,CAAG,GAAGE,IAAU,KAAK,IAAI,KAAK,IAAI,GAAGD,CAAM,IAAI,KAAKhB,EAAS,UAAU;AAC5G,SAAK,gBAAgB,IAAIiB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,IAAI,SAAS;AACX,WAAO,KAAK,gBAAgB,KAAK,MAAM,MAAM,KAAK,aAAa,IAAI;AAAA,EACpE;AAAA,EACD,IAAI,OAAOF,GAAK;AACd,QAAIA,MAAQ;AACV,WAAK,gBAAgB;AAAA,SAClB;AACH,YAAMG,IAAS,KAAK,IAAI,KAAK,QAAQH,CAAG;AACxC,WAAK,gBAAgB,KAAKG,IAAS;AAAA,IACpC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4CD,WAAW,SAAS;AAClB,QAAI,CAAClB,EAAS,SAAS;AACrB,YAAMmB,IAASnB,EAAS,UAAU,IAAIA,EAAQ;AAC9C,MAAAmB,EAAO,YAAY,IAAIA,EAAO,aAAa;AAAA,IAC5C;AACD,WAAOnB,EAAS;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,WAAW,SAAS;AAClB,QAAI,CAACA,EAAS,SAAS;AACrB,YAAMoB,IAASpB,EAAS,UAAU,IAAIA,EAAQ;AAC9C,MAAAoB,EAAO,YAAY,IAAIA,EAAO,aAAa;AAAA,IAC5C;AACD,WAAOpB,EAAS;AAAA,EACjB;AACH;AACAD,EAAQ,aAAa;AAClB,IAACsB,IAAStB;","x_google_ignoreList":[0]}