{"version":3,"file":"index194.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/geometry/Geometry.mjs"],"sourcesContent":["import { BUFFER_TYPE } from \"@pixi/constants\";\nimport { Runner } from \"@pixi/runner\";\nimport { getBufferType } from \"@pixi/utils\";\nimport { Attribute } from \"./Attribute.mjs\";\nimport { Buffer } from \"./Buffer.mjs\";\nimport { interleaveTypedArrays } from \"./utils/interleaveTypedArrays.mjs\";\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet UID = 0;\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nclass Geometry {\n  /**\n   * @param buffers - An array of buffers. optional.\n   * @param attributes - Of the geometry, optional structure of the attributes layout\n   */\n  constructor(buffers = [], attributes = {}) {\n    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner(\"disposeGeometry\"), this.refCount = 0;\n  }\n  /**\n   *\n   * Adds an attribute to the geometry\n   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!\n   * @param id - the name of the attribute (matching up to a shader)\n   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param normalized - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param instance - Instancing flag\n   * @returns - Returns self, useful for chaining.\n   */\n  addAttribute(id, buffer, size = 0, normalized = !1, type, stride, start, instance = !1) {\n    if (!buffer)\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer(buffer));\n    const ids = id.split(\"|\");\n    if (ids.length > 1) {\n      for (let i = 0; i < ids.length; i++)\n        this.addAttribute(ids[i], buffer, size, normalized, type);\n      return this;\n    }\n    let bufferIndex = this.buffers.indexOf(buffer);\n    return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  }\n  /**\n   *\n   * Adds an index buffer to the geometry\n   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, â€¦). There is only ONE index buffer.\n   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n   * @returns - Returns self, useful for chaining.\n   */\n  addIndex(buffer) {\n    return buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer(buffer)), buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * This function modifies the structure so that all current attributes become interleaved into a single buffer\n   * This can be useful if your model remains static as it offers a little performance boost\n   * @returns - Returns self, useful for chaining.\n   */\n  interleave() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    const arrays = [], sizes = [], interleavedBuffer = new Buffer();\n    let i;\n    for (i in this.attributes) {\n      const attribute = this.attributes[i], buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0;\n    }\n    for (interleavedBuffer.data = interleaveTypedArrays(arrays, sizes), i = 0; i < this.buffers.length; i++)\n      this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();\n    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }\n  /** Get the size of the geometries, in vertices. */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys the geometry. */\n  destroy() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }\n  /**\n   * Returns a clone of the geometry.\n   * @returns - A new clone of this geometry.\n   */\n  clone() {\n    const geometry = new Geometry();\n    for (let i = 0; i < this.buffers.length; i++)\n      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));\n    for (const i in this.attributes) {\n      const attrib = this.attributes[i];\n      geometry.attributes[i] = new Attribute(\n        attrib.buffer,\n        attrib.size,\n        attrib.normalized,\n        attrib.type,\n        attrib.stride,\n        attrib.start,\n        attrib.instance\n      );\n    }\n    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;\n  }\n  /**\n   * Merges an array of geometries into a new single one.\n   *\n   * Geometry attribute styles must match for this operation to work.\n   * @param geometries - array of geometries to merge\n   * @returns - Shiny new geometry!\n   */\n  static merge(geometries) {\n    const geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [];\n    let geometry;\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0;\n    }\n    for (let i = 0; i < geometry.buffers.length; i++)\n      arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]), geometryOut.buffers[i] = new Buffer(arrays[i]);\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        arrays[j].set(geometry.buffers[j].data, offsets[j]), offsets[j] += geometry.buffers[j].data.length;\n    }\n    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;\n      for (let i = 0; i < geometry.buffers.length; i++)\n        if (geometry.buffers[i] !== geometry.indexBuffer) {\n          bufferIndexToCount = i;\n          break;\n        }\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4);\n      }\n      for (let i = 0; i < geometries.length; i++) {\n        const indexBufferData = geometries[i].indexBuffer.data;\n        for (let j = 0; j < indexBufferData.length; j++)\n          geometryOut.indexBuffer.data[j + offset2] += offset;\n        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  }\n}\nexport {\n  Geometry\n};\n//# sourceMappingURL=Geometry.mjs.map\n"],"names":["byteSizeMap","UID","map","Geometry","buffers","attributes","Runner","id","buffer","size","normalized","type","stride","start","instance","Buffer","ids","i","bufferIndex","Attribute","BUFFER_TYPE","arrays","sizes","interleavedBuffer","attribute","interleaveTypedArrays","geometry","attrib","geometries","geometryOut","offsets","j","getBufferType","offset","offset2","bufferIndexToCount","indexBufferData"],"mappings":"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","x_google_ignoreList":[0]}