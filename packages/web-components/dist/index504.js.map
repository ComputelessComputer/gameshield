{"version":3,"file":"index504.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"],"sourcesContent":["import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n"],"names":["RECURSION_LIMIT","FLT_EPSILON","PATH_DISTANCE_EPSILON","buildAdaptiveQuadratic","points","sX","sY","cp1x","cp1y","eX","eY","smoothness","smoothing","GraphicsContextSystem","distanceTolerance","begin","recursive","x1","y1","x2","y2","x3","y3","level","x12","y12","x23","y23","x123","y123","dx","dy"],"mappings":";AAGA,MAAMA,IAAkB,GAClBC,IAAc,cACdC,IAAwB;AAG9B,SAASC,EAAuBC,GAAQC,GAAIC,GAAIC,GAAMC,GAAMC,GAAIC,GAAIC,GAAY;AAE9E,QAAMC,IAAY,KAAK;AAAA,IACrB;AAAA;AAAA,IAEA,KAAK,IAAI,GAAGD,KAAcE,EAAsB,eAAe,gBAAgB;AAAA,EACnF;AACE,MAAIC,KAAqBZ,IAAwBU,KAAa;AAC9D,SAAAE,KAAqBA,GACrBC,EAAMV,GAAIC,GAAIC,GAAMC,GAAMC,GAAIC,GAAIN,GAAQU,CAAiB,GACpDV;AACT;AACA,SAASW,EAAMV,GAAIC,GAAIC,GAAMC,GAAMC,GAAIC,GAAIN,GAAQU,GAAmB;AACpE,EAAAE,EAAUZ,GAAQC,GAAIC,GAAIC,GAAMC,GAAMC,GAAIC,GAAII,GAAmB,CAAC,GAClEV,EAAO,KAAKK,GAAIC,CAAE;AACpB;AACA,SAASM,EAAUZ,GAAQa,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIR,GAAmBS,GAAO;AAC3E,MAAIA,IAAQvB;AACV;AAGF,QAAMwB,KAAOP,IAAKE,KAAM,GAClBM,KAAOP,IAAKE,KAAM,GAClBM,KAAOP,IAAKE,KAAM,GAClBM,KAAOP,IAAKE,KAAM,GAClBM,KAAQJ,IAAME,KAAO,GACrBG,KAAQJ,IAAME,KAAO;AAC3B,MAAIG,IAAKT,IAAKJ,GACVc,IAAKT,IAAKJ;AACd,QAAM,IAAI,KAAK,KAAKC,IAAKE,KAAMU,KAAMX,IAAKE,KAAMQ,CAAE;AAClD,MAAI,IAAI7B;AACN,QAAI,IAAI,KAAKa,KAAqBgB,IAAKA,IAAKC,IAAKA,IACG;AAChD,MAAA3B,EAAO,KAAKwB,GAAMC,CAAI;AACtB;AAAA,IACD;AAAA,aAUHC,IAAKF,KAAQX,IAAKI,KAAM,GACxBU,IAAKF,KAAQX,IAAKI,KAAM,GACpBQ,IAAKA,IAAKC,IAAKA,KAAMjB,GAAmB;AAC1C,IAAAV,EAAO,KAAKwB,GAAMC,CAAI;AACtB;AAAA,EACD;AAEH,EAAAb,EAAUZ,GAAQa,GAAIC,GAAIM,GAAKC,GAAKG,GAAMC,GAAMf,GAAmBS,IAAQ,CAAC,GAC5EP,EAAUZ,GAAQwB,GAAMC,GAAMH,GAAKC,GAAKN,GAAIC,GAAIR,GAAmBS,IAAQ,CAAC;AAC9E;","x_google_ignoreList":[0]}