{"version":3,"file":"index81.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs"],"sourcesContent":["import { Ticker } from \"@pixi/ticker\";\nimport { BaseImageResource } from \"./BaseImageResource.mjs\";\nconst _VideoResource = class _VideoResource2 extends BaseImageResource {\n  /**\n   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n   * @param {object} [options] - Options to use\n   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n   * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n   * If 0, `requestVideoFrameCallback` is used to update the texture.\n   * If `requestVideoFrameCallback` is not available, the texture is updated every render.\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {boolean} [options.loop=false] - Loops the video\n   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay\n   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices\n   */\n  constructor(source, options) {\n    if (options = options || {}, !(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement(\"video\");\n      options.autoLoad !== !1 && videoElement.setAttribute(\"preload\", \"auto\"), options.playsinline !== !1 && (videoElement.setAttribute(\"webkit-playsinline\", \"\"), videoElement.setAttribute(\"playsinline\", \"\")), options.muted === !0 && (videoElement.setAttribute(\"muted\", \"\"), videoElement.muted = !0), options.loop === !0 && videoElement.setAttribute(\"loop\", \"\"), options.autoPlay !== !1 && videoElement.setAttribute(\"autoplay\", \"\"), typeof source == \"string\" && (source = [source]);\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement(\"source\");\n        let { src, mime } = source[i];\n        if (src = src || source[i], src.startsWith(\"data:\"))\n          mime = src.slice(5, src.indexOf(\";\"));\n        else if (!src.startsWith(\"blob:\")) {\n          const baseSrc = src.split(\"?\").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;\n        }\n        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== !1, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Trigger updating of the texture.\n   * @param _deltaTime - time delta since last tick\n   */\n  update(_deltaTime = 0) {\n    if (!this.destroyed) {\n      if (this._updateFPS) {\n        const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      }\n      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(\n        /* deltaTime*/\n      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }\n  _videoFrameRequestCallback() {\n    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    );\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<void>} Handle the validate event\n   */\n  load() {\n    if (this._load)\n      return this._load;\n    const source = this.source;\n    return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener(\"play\", this._onPlayStart), source.addEventListener(\"pause\", this._onPlayStop), source.addEventListener(\"seeked\", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener(\"canplay\", this._onCanPlay), source.addEventListener(\"canplaythrough\", this._onCanPlay), source.addEventListener(\"error\", this._onError, !0)), this._load = new Promise((resolve, reject) => {\n      this.valid ? resolve(this) : (this._resolve = resolve, this._reject = reject, source.load());\n    }), this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event\n   */\n  _onError(event) {\n    this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);\n  }\n  /**\n   * Returns true if the underlying source is playing.\n   * @returns - True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Returns true if the underlying source is ready for playing.\n   * @returns - True if ready.\n   */\n  _isSourceReady() {\n    return this.source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    this.valid || this._onCanPlay(), this._configureAutoUpdate();\n  }\n  /** Fired when a pause event is triggered, stops the update loop. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Fired when the video is completed seeking to the current playback position. */\n  _onSeeked() {\n    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener(\"canplay\", this._onCanPlay), source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    const valid = this.valid;\n    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();\n  }\n  /** Destroys this texture. */\n  dispose() {\n    this._configureAutoUpdate();\n    const source = this.source;\n    source && (source.removeEventListener(\"play\", this._onPlayStart), source.removeEventListener(\"pause\", this._onPlayStop), source.removeEventListener(\"seeked\", this._onSeeked), source.removeEventListener(\"canplay\", this._onCanPlay), source.removeEventListener(\"canplaythrough\", this._onCanPlay), source.removeEventListener(\"error\", this._onError, !0), source.pause(), source.src = \"\", source.load()), super.dispose();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());\n  }\n  /**\n   * How many times a second to update the texture from the video. If 0, `requestVideoFrameCallback` is used to\n   * update the texture. If `requestVideoFrameCallback` is not available, the texture is updated every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());\n  }\n  _configureAutoUpdate() {\n    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} `true` if video source\n   */\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);\n  }\n};\n_VideoResource.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], /**\n* Map of video MIME types that can't be directly derived from file extensions.\n* @readonly\n*/\n_VideoResource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoResource = _VideoResource;\nexport {\n  VideoResource\n};\n//# sourceMappingURL=VideoResource.mjs.map\n"],"names":["_VideoResource","_VideoResource2","BaseImageResource","source","options","videoElement","firstSrc","i","sourceElement","src","mime","baseSrc","ext","_deltaTime","elapsedMS","Ticker","resolve","reject","event","valid","value","extension","VideoResource"],"mappings":"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","x_google_ignoreList":[0]}