{"version":3,"file":"index132.js","sources":["../../../node_modules/.pnpm/@pixi+sprite@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3_/node_modules/@pixi/sprite/lib/Sprite.mjs"],"sourcesContent":["import { Point, ObservablePoint, Color, BLEND_MODES, Texture, settings, utils, Rectangle } from \"@pixi/core\";\nimport { Container, Bounds } from \"@pixi/display\";\nconst tempPoint = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nclass Sprite extends Container {\n  /** @param texture - The texture for this sprite. */\n  constructor(texture) {\n    super(), this._anchor = new ObservablePoint(\n      this._onAnchorUpdate,\n      this,\n      texture ? texture.defaultAnchor.x : 0,\n      texture ? texture.defaultAnchor.y : 0\n    ), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.pluginName = \"batch\", this.isSprite = !0, this._roundPixels = settings.ROUND_PIXELS;\n  }\n  /** When the texture is updated, this event will fire to update the scale and frame. */\n  _onTextureUpdate() {\n    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = utils.sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = utils.sign(this.scale.y) * this._height / this._texture.orig.height);\n  }\n  /** Called when the anchor position updates. */\n  _onAnchorUpdate() {\n    this._transformID = -1, this._transformTrimmedID = -1;\n  }\n  /** Calculates worldTransform * vertices, store it in vertexData. */\n  calculateVertices() {\n    const texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)\n      return;\n    this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = texture._updateID;\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, trim = texture.trim, orig = texture.orig, anchor = this._anchor;\n    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;\n    if (trim ? (w1 = trim.x - anchor._x * orig.width, w0 = w1 + trim.width, h1 = trim.y - anchor._y * orig.height, h0 = h1 + trim.height) : (w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height), vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n  }\n  /**\n   * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.\n   *\n   * This is used to ensure that the true width and height of a trimmed texture is respected.\n   */\n  calculateTrimmedVertices() {\n    if (!this.vertexTrimmedData)\n      this.vertexTrimmedData = new Float32Array(8);\n    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n      return;\n    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n    const texture = this._texture, vertexData = this.vertexTrimmedData, orig = texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height;\n    if (vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n  }\n  /**\n   *\n   * Renders the object using the WebGL renderer\n   * @param renderer - The webgl renderer to use.\n   */\n  _render(renderer) {\n    this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this);\n  }\n  /** Updates the bounds of the sprite. */\n  _calculateBounds() {\n    const trim = this._texture.trim, orig = this._texture.orig;\n    !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n  }\n  /**\n   * Gets the local bounds of the sprite object.\n   * @param rect - Optional output rectangle.\n   * @returns The bounds.\n   */\n  getLocalBounds(rect) {\n    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);\n  }\n  /**\n   * Tests if a point is inside this sprite\n   * @param point - the point to test\n   * @returns The result of the test\n   */\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    const width = this._texture.orig.width, height = this._texture.orig.height, x1 = -width * this.anchor.x;\n    let y1 = 0;\n    return tempPoint.x >= x1 && tempPoint.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height);\n  }\n  /**\n   * Destroys this sprite and optionally its texture and children.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  destroy(options) {\n    if (super.destroy(options), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null, typeof options == \"boolean\" ? options : options?.texture) {\n      const destroyBaseTexture = typeof options == \"boolean\" ? options : options?.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  }\n  // some helper functions..\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n   *     - Source to create texture from\n   * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @returns The newly created sprite\n   */\n  static from(source, options) {\n    const texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new Sprite(texture);\n  }\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   *\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   *\n   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n   * @default false\n   */\n  set roundPixels(value) {\n    this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1), this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    const s = utils.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width, this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    const s = utils.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height, this._height = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite(Texture.WHITE);\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    this._anchor.copyFrom(value);\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber();\n  }\n  /**\n   * Get the tint as a RGB integer.\n   * @ignore\n   */\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture !== value && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = value || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once(\"update\", this._onTextureUpdate, this)));\n  }\n}\nexport {\n  Sprite\n};\n//# sourceMappingURL=Sprite.mjs.map\n"],"names":["tempPoint","Point","indices","Sprite","Container","texture","ObservablePoint","Color","BLEND_MODES","Texture","settings","utils.sign","wt","a","b","c","d","tx","ty","vertexData","trim","orig","anchor","w0","w1","h0","h1","resolution","i","renderer","rect","Bounds","Rectangle","point","width","height","x1","y1","options","destroyBaseTexture","source","value","s"],"mappings":"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","x_google_ignoreList":[0]}