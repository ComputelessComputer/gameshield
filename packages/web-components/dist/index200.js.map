{"version":3,"file":"index200.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/textures/TextureMatrix.mjs"],"sourcesContent":["import { Matrix } from \"@pixi/math\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this._texture = texture, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > \"u\" ? 0.5 : clampMargin, this.isSimple = !1;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture = value, this._textureID = -1;\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    out === void 0 && (out = uvs);\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i], y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx, out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed.\n   * @param [forceUpdate=false] - if true, matrices will be updated any case\n   * @returns - Whether or not it was updated\n   */\n  update(forceUpdate) {\n    const tex = this._texture;\n    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)\n      return !1;\n    this._textureID = tex._updateID, this._updateID++;\n    const uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig, trim = tex.trim;\n    trim && (tempMat.set(\n      orig.width / trim.width,\n      0,\n      0,\n      orig.height / trim.height,\n      -trim.x / trim.width,\n      -trim.y / trim.height\n    ), this.mapCoord.append(tempMat));\n    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;\n    return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, !0;\n  }\n}\nexport {\n  TextureMatrix\n};\n//# sourceMappingURL=TextureMatrix.mjs.map\n"],"names":["tempMat","Matrix","TextureMatrix","texture","clampMargin","value","uvs","out","mat","i","x","y","forceUpdate","tex","orig","trim","texBase","frame","margin","offset"],"mappings":";;;;;;;;;;AACA,MAAMA,IAAU,IAAIC;AACpB,MAAMC,EAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAKlB,YAAYC,GAASC,GAAa;AAChC,SAAK,WAAWD,GAAS,KAAK,WAAW,IAAIF,EAAQ,GAAE,KAAK,cAAc,IAAI,aAAa,CAAC,GAAG,KAAK,eAAe,IAAI,aAAa,CAAC,GAAG,KAAK,aAAa,IAAI,KAAK,YAAY,GAAG,KAAK,cAAc,GAAG,KAAK,cAAc,OAAOG,IAAc,MAAM,MAAMA,GAAa,KAAK,WAAW;AAAA,EAC1R;AAAA;AAAA,EAED,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,QAAQC,GAAO;AACjB,SAAK,WAAWA,GAAO,KAAK,aAAa;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,YAAYC,GAAKC,GAAK;AACpB,IAAAA,MAAQ,WAAWA,IAAMD;AACzB,UAAME,IAAM,KAAK;AACjB,aAASC,IAAI,GAAGA,IAAIH,EAAI,QAAQG,KAAK,GAAG;AACtC,YAAMC,IAAIJ,EAAIG,CAAC,GAAGE,IAAIL,EAAIG,IAAI,CAAC;AAC/B,MAAAF,EAAIE,CAAC,IAAIC,IAAIF,EAAI,IAAIG,IAAIH,EAAI,IAAIA,EAAI,IAAID,EAAIE,IAAI,CAAC,IAAIC,IAAIF,EAAI,IAAIG,IAAIH,EAAI,IAAIA,EAAI;AAAA,IACnF;AACD,WAAOD;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,OAAOK,GAAa;AAClB,UAAMC,IAAM,KAAK;AACjB,QAAI,CAACA,KAAO,CAACA,EAAI,SAAS,CAACD,KAAe,KAAK,eAAeC,EAAI;AAChE,aAAO;AACT,SAAK,aAAaA,EAAI,WAAW,KAAK;AACtC,UAAMP,IAAMO,EAAI;AAChB,SAAK,SAAS,IAAIP,EAAI,KAAKA,EAAI,IAAIA,EAAI,KAAKA,EAAI,IAAIA,EAAI,KAAKA,EAAI,IAAIA,EAAI,KAAKA,EAAI,IAAIA,EAAI,IAAIA,EAAI,EAAE;AACpG,UAAMQ,IAAOD,EAAI,MAAME,IAAOF,EAAI;AAClC,IAAAE,MAASf,EAAQ;AAAA,MACfc,EAAK,QAAQC,EAAK;AAAA,MAClB;AAAA,MACA;AAAA,MACAD,EAAK,SAASC,EAAK;AAAA,MACnB,CAACA,EAAK,IAAIA,EAAK;AAAA,MACf,CAACA,EAAK,IAAIA,EAAK;AAAA,IAChB,GAAE,KAAK,SAAS,OAAOf,CAAO;AAC/B,UAAMgB,IAAUH,EAAI,aAAaI,IAAQ,KAAK,aAAaC,IAAS,KAAK,cAAcF,EAAQ,YAAYG,IAAS,KAAK;AACzH,WAAOF,EAAM,CAAC,KAAKJ,EAAI,OAAO,IAAIK,IAASC,KAAUH,EAAQ,OAAOC,EAAM,CAAC,KAAKJ,EAAI,OAAO,IAAIK,IAASC,KAAUH,EAAQ,QAAQC,EAAM,CAAC,KAAKJ,EAAI,OAAO,IAAIA,EAAI,OAAO,QAAQK,IAASC,KAAUH,EAAQ,OAAOC,EAAM,CAAC,KAAKJ,EAAI,OAAO,IAAIA,EAAI,OAAO,SAASK,IAASC,KAAUH,EAAQ,QAAQ,KAAK,aAAa,CAAC,IAAIG,IAASH,EAAQ,WAAW,KAAK,aAAa,CAAC,IAAIG,IAASH,EAAQ,YAAY,KAAK,WAAWH,EAAI,OAAO,UAAUG,EAAQ,SAASH,EAAI,OAAO,WAAWG,EAAQ,UAAUH,EAAI,WAAW,GAAG;AAAA,EAC5f;AACH;","x_google_ignoreList":[0]}