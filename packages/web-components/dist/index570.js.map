{"version":3,"file":"index570.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n"],"names":["contextSettings","_CanvasTextMetrics","result","proto","DOMAdapter","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","canvas","wordWrap","textKey","font","fontStringFromTextStyle","context","i","lineWidth","strokeWidth","_a","letterSpacing","useExperimentalLetterSpacing","metrics","metricWidth","actualBoundingBoxLeft","boundsWidth","val","line","cache","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","token","currIsBreakingSpace","lastIsBreakingSpace","tokenWidth","characters","j","char","lastChar","k","nextChar","characterWidth","isLastToken","newLine","key","_nextChar","_token","breakWords","_char","_index","_breakWords","properties","c","segmenter","s","x","CanvasTextMetrics"],"mappings":"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","x_google_ignoreList":[0]}