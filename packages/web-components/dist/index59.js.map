{"version":3,"file":"index59.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/mask/MaskSystem.mjs"],"sourcesContent":["import { MASK_TYPES } from \"@pixi/constants\";\nimport { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { SpriteMaskFilter } from \"../filters/spriteMask/SpriteMaskFilter.mjs\";\nimport { MaskData } from \"./MaskData.mjs\";\nclass MaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  /**\n   * Changes the mask stack that is used by this System.\n   * @param maskStack - The mask stack\n   */\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);\n  }\n  /**\n   * Enables the mask and appends it to the current mask stack.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n   * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n   */\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = !0, d.maskObject = maskDataOrTarget, maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case MASK_TYPES.SPRITE:\n          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    maskData.type === MASK_TYPES.SPRITE && this.maskStack.push(maskData);\n  }\n  /**\n   * Removes the last mask from the mask stack and doesn't return it.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n   */\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!(!maskData || maskData._target !== target)) {\n      if (maskData.enabled)\n        switch (maskData.type) {\n          case MASK_TYPES.SCISSOR:\n            this.renderer.scissor.pop(maskData);\n            break;\n          case MASK_TYPES.STENCIL:\n            this.renderer.stencil.pop(maskData.maskObject);\n            break;\n          case MASK_TYPES.SPRITE:\n            this.popSpriteMask(maskData);\n            break;\n          case MASK_TYPES.COLOR:\n            this.popColorMask(maskData);\n            break;\n          default:\n            break;\n        }\n      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {\n        const maskCurrent = this.maskStack[this.maskStack.length - 1];\n        maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);\n      }\n    }\n  }\n  /**\n   * Sets type of MaskData based on its maskObject.\n   * @param maskData\n   */\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    maskObject ? maskObject.isSprite ? maskData.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = MASK_TYPES.SCISSOR : maskData.type = MASK_TYPES.STENCIL : maskData.type = MASK_TYPES.COLOR;\n  }\n  /**\n   * Applies the Mask and adds it to the current filter stack.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  pushSpriteMask(maskData) {\n    const { maskObject } = maskData, target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(!0), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;\n  }\n  /**\n   * Removes the last filter from the filter stack and doesn't return it.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }\n  /**\n   * Pushes the color mask.\n   * @param maskData - The mask data\n   */\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  /**\n   * Pops the color mask.\n   * @param maskData - The mask data\n   */\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"mask\"\n};\nextensions.add(MaskSystem);\nexport {\n  MaskSystem\n};\n//# sourceMappingURL=MaskSystem.mjs.map\n"],"names":["MaskSystem","renderer","maskStack","target","maskDataOrTarget","maskData","d","MaskData","maskAbove","MASK_TYPES","maskCurrent","maskObject","alphaMaskFilter","SpriteMaskFilter","stashFilterArea","currColorMask","nextColorMask","ExtensionType","extensions"],"mappings":"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","x_google_ignoreList":[0]}