{"version":3,"file":"index490.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs"],"sourcesContent":["import { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\nimport { multiplyColors } from '../utils/multiplyColors.mjs';\n\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixPool.return(parentTransform);\n    return matrix;\n  },\n  /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(\n          multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n        );\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\n\nexport { bgr2rgb, getGlobalMixin };\n//# sourceMappingURL=getGlobalMixin.mjs.map\n"],"names":["bgr2rgb","color","getGlobalMixin","skipUpdate","alpha","current","matrix","parentTransform","updateTransformBackwards","matrixPool","multiplyColors","parent"],"mappings":";;;AAKA,SAASA,EAAQC,GAAO;AACtB,WAASA,IAAQ,QAAQ,OAAOA,IAAQ,UAAUA,KAAS,KAAK;AAClE;AACK,MAACC,IAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcrB,eAAeC,GAAY;AACzB,QAAIA;AACF,aAAI,KAAK,cACA,KAAK,YAAY,aAEtB,KAAK,oBACA,KAAK,kBAAkB,aAAa,KAAK,QAE3C,KAAK;AAEd,QAAIC,IAAQ,KAAK,OACbC,IAAU,KAAK;AACnB,WAAOA;AACL,MAAAD,KAASC,EAAQ,OACjBA,IAAUA,EAAQ;AAEpB,WAAOD;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBD,mBAAmBE,GAAQH,GAAY;AACrC,QAAIA;AACF,aAAOG,EAAO,SAAS,KAAK,cAAc;AAE5C,SAAK,qBAAoB;AACzB,UAAMC,IAAkBC,EAAyB,MAAMC,EAAW,IAAK,EAAC,SAAQ,CAAE;AAClF,WAAAH,EAAO,WAAW,KAAK,gBAAgBC,CAAe,GACtDE,EAAW,OAAOF,CAAe,GAC1BD;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcD,cAAcH,GAAY;AACxB,QAAIA;AACF,aAAI,KAAK,cACAH,EAAQ,KAAK,YAAY,UAAU,IAExC,KAAK,oBACAA;AAAA,QACLU,EAAe,KAAK,YAAY,KAAK,kBAAkB,UAAU;AAAA,MAC3E,IAEa,KAAK;AAEd,QAAIT,IAAQ,KAAK,YACbU,IAAS,KAAK;AAClB,WAAOA;AACL,MAAAV,IAAQS,EAAeT,GAAOU,EAAO,UAAU,GAC/CA,IAASA,EAAO;AAElB,WAAOX,EAAQC,CAAK;AAAA,EACrB;AACH;","x_google_ignoreList":[0]}