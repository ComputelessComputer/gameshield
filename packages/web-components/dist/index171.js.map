{"version":3,"file":"index171.js","sources":["../../../node_modules/.pnpm/@pixi+events@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3_/node_modules/@pixi/events/lib/EventBoundary.mjs"],"sourcesContent":["import { Point, utils } from \"@pixi/core\";\nimport { EventsTicker } from \"./EventTicker.mjs\";\nimport { FederatedMouseEvent } from \"./FederatedMouseEvent.mjs\";\nimport { FederatedPointerEvent } from \"./FederatedPointerEvent.mjs\";\nimport { FederatedWheelEvent } from \"./FederatedWheelEvent.mjs\";\nconst PROPAGATION_LIMIT = 2048, tempHitLocation = new Point(), tempLocalMapping = new Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    this.dispatch = new utils.EventEmitter(), this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {\n      trackingData: {}\n    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping(\"pointerdown\", this.mapPointerDown), this.addEventMapping(\"pointermove\", this.mapPointerMove), this.addEventMapping(\"pointerout\", this.mapPointerOut), this.addEventMapping(\"pointerleave\", this.mapPointerOut), this.addEventMapping(\"pointerover\", this.mapPointerOver), this.addEventMapping(\"pointerup\", this.mapPointerUp), this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside), this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({\n      fn,\n      priority: 0\n    }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e\n   * @param type\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e\n   */\n  mapEvent(e) {\n    if (!this.rootTarget)\n      return;\n    const mappers = this.mappingTable[e.type];\n    if (mappers)\n      for (let i = 0, j = mappers.length; i < j; i++)\n        mappers[i].fn(e);\n    else\n      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n  }\n  /**\n   * Finds the DisplayObject that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x\n   * @param y\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = !0;\n    const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? \"hitTestMoveRecursive\" : \"hitTestRecursive\", invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type\n   */\n  propagate(e, type) {\n    if (!e.target)\n      return;\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++)\n      if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !(e.propagationStopped || e.propagationImmediatelyStopped)) {\n      e.eventPhase = e.BUBBLING_PHASE;\n      for (let i = composedPath.length - 2; i >= 0; i--)\n        if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n          return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive display objects. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--)\n      events.forEach((event) => {\n        e.currentTarget = targets[i], this.notifyTarget(e, event);\n      });\n  }\n  /**\n   * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n      if (!target.parent)\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      propagationPath.push(target.parent), target = target.parent;\n    }\n    return propagationPath.reverse(), propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = !1) {\n    let shouldReturn = !1;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if ((currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") && (EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = !0;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  /**\n   * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The DisplayObject that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the display object.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n      return null;\n    if ((currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") && (EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(displayObject) {\n    return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === \"none\" || displayObject.eventMode === \"passive\" && !displayObject.interactiveChildren || displayObject.isMask);\n  }\n  /**\n   * Checks whether the display object or any of its children cannot pass the hit test at all.\n   *\n   * {@link PIXI.EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n   * and {@link PIXI.DisplayObject._mask} for pruning.\n   * @param displayObject\n   * @param location\n   */\n  hitPruneFn(displayObject, location) {\n    if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))\n      return !0;\n    if (displayObject._mask) {\n      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n      if (maskObject && !maskObject.containsPoint?.(location))\n        return !0;\n    }\n    return !1;\n  }\n  /**\n   * Checks whether the display object passes hit testing for the given location.\n   * @param displayObject\n   * @param location\n   * @returns - Whether `displayObject` passes hit testing for `location`.\n   */\n  hitTestFn(displayObject, location) {\n    return displayObject.eventMode === \"passive\" ? !1 : displayObject.hitArea ? !0 : displayObject.containsPoint ? displayObject.containsPoint(location) : !1;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type\n   */\n  notifyTarget(e, type) {\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, \"pointerdown\"), e.pointerType === \"touch\")\n      this.dispatchEvent(e, \"touchstart\");\n    else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = !1;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\", trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\", outEvent = this.createPointerEvent(from, outType, outTarget);\n      if (this.dispatchEvent(outEvent, \"pointerout\"), isMouse && this.dispatchEvent(outEvent, \"mouseout\"), !e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); )\n          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), leaveEvent.target = leaveEvent.target.parent;\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\", overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\"), isMouse && this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; )\n        overTargetAncestor = overTargetAncestor.parent;\n      if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )\n          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), enterEvent.target = enterEvent.target.parent;\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? !0;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\"), allowGlobalPointerEvents && allMethods.push(\"globalpointermove\"), e.pointerType === \"touch\" && (this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\"), allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\"), allowGlobalPointerEvents && allMethods.push(\"globalmousemove\"), this.cursor = e.target?.cursor), allMethods.length > 0 && this.all(e, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from), isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\"), isMouse && this.dispatchEvent(e, \"mouseover\"), e.pointerType === \"mouse\" && (this.cursor = e.target?.cursor);\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )\n      enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), enterEvent.target = enterEvent.target.parent;\n    trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )\n        leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), leaveEvent.target = leaveEvent.target.parent;\n      trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now(), e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, \"pointerup\"), e.pointerType === \"touch\")\n      this.dispatchEvent(e, \"touchend\");\n    else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      for (; currentTarget && !e.composedPath().includes(currentTarget); ) {\n        if (e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), e.pointerType === \"touch\")\n          this.notifyTarget(e, \"touchendoutside\");\n        else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {\n        clickCount: 0,\n        target: clickEvent.target,\n        timeStamp: now\n      });\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else\n        clickEvent.pointerType === \"touch\" && this.dispatchEvent(clickEvent, \"tap\");\n      this.dispatchEvent(clickEvent, \"pointertap\"), this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link PIXI.EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      for (; currentTarget; )\n        e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), e.pointerType === \"touch\" ? this.notifyTarget(e, \"touchendoutside\") : (e.pointerType === \"mouse\" || e.pointerType === \"pen\") && this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\"), currentTarget = currentTarget.parent;\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      console.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath)\n      return null;\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++)\n      currentTarget = propagationPath[i];\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type == \"string\" && (event.type = type), event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;\n  }\n  /**\n   * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from\n   * @param to\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from\n   * @param to\n   */\n  copyPointerData(from, to) {\n    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);\n  }\n  /**\n   * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from\n   * @param to\n   */\n  copyMouseData(from, to) {\n    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));\n  }\n  /**\n   * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = performance.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {\n      pressTargetsByButton: {},\n      clicksByButton: {},\n      overTarget: null\n    }), this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (listeners && e.currentTarget.isInteractive())\n      if (\"fn\" in listeners)\n        listeners.once && e.currentTarget.removeListener(type, listeners.fn, void 0, !0), listeners.fn.call(listeners.context, e);\n      else\n        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)\n          listeners[i].once && e.currentTarget.removeListener(type, listeners[i].fn, void 0, !0), listeners[i].fn.call(listeners[i].context, e);\n  }\n}\nexport {\n  EventBoundary\n};\n//# sourceMappingURL=EventBoundary.mjs.map\n"],"names":["PROPAGATION_LIMIT","tempHitLocation","Point","tempLocalMapping","EventBoundary","rootTarget","utils.EventEmitter","type","fn","a","b","e","mappers","j","x","y","EventsTicker","invertedPath","composedPath","i","targets","events","event","target","propagationPath","currentTarget","eventMode","location","testFn","pruneFn","ignore","shouldReturn","children","child","nestedHit","isInteractive","isInteractiveMode","isInteractiveTarget","int","displayObject","maskObject","_a","handlerKey","_b","key","from","FederatedPointerEvent","isRightButton","trackingData","isMouse","outTarget","outType","outEvent","leaveEvent","overType","overEvent","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","now","pressTarget","clickTarget","clickEvent","clickHistory","FederatedWheelEvent","wheelEvent","to","FederatedMouseEvent","id","constructor","listeners"],"mappings":"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","x_google_ignoreList":[0]}