{"version":3,"file":"index497.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    this.gcTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    this.isCachedAsTexture = false;\n    this._matrixDirty = 7;\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      child._updateFlags = 15;\n      this.addChild(child);\n    }\n  }\n  enableCacheAsTexture(options = {}) {\n    this.textureOptions = options;\n    this.isCachedAsTexture = true;\n    this.textureNeedsUpdate = true;\n  }\n  disableCacheAsTexture() {\n    this.isCachedAsTexture = false;\n    if (this.texture) {\n      TexturePool.returnTexture(this.texture);\n      this.texture = null;\n    }\n  }\n  updateCacheTexture() {\n    this.textureNeedsUpdate = true;\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n    this.disableCacheAsTexture();\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7)\n      return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender(renderer) {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender(renderer);\n    }\n  }\n  destroy() {\n    this.disableCacheAsTexture();\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  invalidateMatrices() {\n    this._matrixDirty = 7;\n  }\n  /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */\n  get inverseWorldTransform() {\n    if ((this._matrixDirty & 1) === 0)\n      return this._inverseWorldTransform;\n    this._matrixDirty &= ~1;\n    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());\n    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n  }\n  /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */\n  get textureOffsetInverseTransform() {\n    if ((this._matrixDirty & 2) === 0)\n      return this._textureOffsetInverseTransform;\n    this._matrixDirty &= ~2;\n    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());\n    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(\n      -this._textureBounds.x,\n      -this._textureBounds.y\n    );\n  }\n  /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */\n  get inverseParentTextureTransform() {\n    if ((this._matrixDirty & 4) === 0)\n      return this._inverseParentTextureTransform;\n    this._matrixDirty &= ~4;\n    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n    if (parentCacheAsTexture) {\n      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());\n      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(\n        -parentCacheAsTexture._textureBounds.x,\n        -parentCacheAsTexture._textureBounds.y\n      );\n    }\n    return this.worldTransform;\n  }\n  /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */\n  get cacheToLocalTransform() {\n    if (!this._parentCacheAsTextureRenderGroup)\n      return null;\n    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n"],"names":["RenderGroup","Matrix","InstructionSet","root","children","i","child","options","TexturePool","childrenAtDepth","renderGroupChild","index","childrenToUpdate","renderable","container","renderer","out","parentCacheAsTexture"],"mappings":"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","x_google_ignoreList":[0]}