{"version":3,"file":"index422.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    this._dataInt32 = null;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size ?? (size = data?.byteLength);\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  get dataInt32() {\n    if (!this._dataInt32) {\n      this._dataInt32 = new Int32Array(this.data.buffer);\n    }\n    return this._dataInt32;\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    this._dataInt32 = null;\n    if (!oldData || oldData.length !== value.length) {\n      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n"],"names":["Buffer","EventEmitter","options","data","size","usage","label","shrinkToFit","uid","mappedAtCreation","value","BufferUsage","syncGPU","oldData","sizeInBytes"],"mappings":";;;AAKA,MAAMA,UAAeC,EAAa;AAAA;AAAA;AAAA;AAAA;AAAA,EAKhC,YAAYC,GAAS;AACnB,QAAI,EAAE,MAAAC,GAAM,MAAAC,EAAM,IAAGF;AACrB,UAAM,EAAE,OAAAG,GAAO,OAAAC,GAAO,aAAAC,EAAW,IAAKL;AACtC,aAgBA,KAAK,MAAMM,EAAI,QAAQ,GAMvB,KAAK,gBAAgB,UAMrB,KAAK,cAAcA,EAAI,UAAU,GAMjC,KAAK,WAAW,GAKhB,KAAK,YAAY,GACjB,KAAK,aAAa,MASlB,KAAK,cAAc,IAKnB,KAAK,YAAY,IACbL,aAAgB,UAClBA,IAAO,IAAI,aAAaA,CAAI,IAE9B,KAAK,QAAQA,GACbC,MAASA,IAAOD,KAAA,gBAAAA,EAAM;AACtB,UAAMM,IAAmB,CAAC,CAACN;AAC3B,SAAK,aAAa;AAAA,MAChB,MAAAC;AAAA,MACA,OAAAC;AAAA,MACA,kBAAAI;AAAA,MACA,OAAAH;AAAA,IACN,GACI,KAAK,cAAcC,KAAe;AAAA,EACnC;AAAA;AAAA,EAED,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,KAAKG,GAAO;AACd,SAAK,gBAAgBA,GAAOA,EAAM,QAAQ,EAAI;AAAA,EAC/C;AAAA,EACD,IAAI,YAAY;AACd,WAAK,KAAK,eACR,KAAK,aAAa,IAAI,WAAW,KAAK,KAAK,MAAM,IAE5C,KAAK;AAAA,EACb;AAAA;AAAA,EAED,IAAI,SAAS;AACX,WAAO,CAAC,EAAE,KAAK,WAAW,QAAQC,EAAY;AAAA,EAC/C;AAAA,EACD,IAAI,OAAOD,GAAO;AAChB,IAAIA,IACF,KAAK,WAAW,SAASC,EAAY,SAErC,KAAK,WAAW,SAAS,CAACA,EAAY;AAAA,EAEzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,gBAAgBD,GAAON,GAAMQ,GAAS;AAGpC,QAFA,KAAK,aACL,KAAK,cAAcR,IAAOM,EAAM,mBAC5B,KAAK,UAAUA,GAAO;AACxB,MAAIE,KACF,KAAK,KAAK,UAAU,IAAI;AAC1B;AAAA,IACD;AACD,UAAMC,IAAU,KAAK;AAGrB,QAFA,KAAK,QAAQH,GACb,KAAK,aAAa,MACd,CAACG,KAAWA,EAAQ,WAAWH,EAAM,QAAQ;AAC/C,MAAI,CAAC,KAAK,eAAeG,KAAWH,EAAM,aAAaG,EAAQ,aACzDD,KACF,KAAK,KAAK,UAAU,IAAI,KAE1B,KAAK,WAAW,OAAOF,EAAM,YAC7B,KAAK,cAAcF,EAAI,UAAU,GACjC,KAAK,KAAK,UAAU,IAAI;AAE1B;AAAA,IACD;AACD,IAAII,KACF,KAAK,KAAK,UAAU,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,OAAOE,GAAa;AAClB,SAAK,cAAcA,KAAe,KAAK,aACvC,KAAK,aACL,KAAK,KAAK,UAAU,IAAI;AAAA,EACzB;AAAA;AAAA,EAED,UAAU;AACR,SAAK,YAAY,IACjB,KAAK,KAAK,WAAW,IAAI,GACzB,KAAK,KAAK,UAAU,IAAI,GACxB,KAAK,QAAQ,MACb,KAAK,aAAa,MAClB,KAAK,mBAAkB;AAAA,EACxB;AACH;","x_google_ignoreList":[0]}