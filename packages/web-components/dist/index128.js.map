{"version":3,"file":"index128.js","sources":["../../game-core/dist/src/games/puzzle.js"],"sourcesContent":["/**\n * Puzzle Game Implementation\n *\n * A sliding puzzle game where players rearrange pieces to form a complete image.\n *\n * @packageDocumentation\n */\nimport * as PIXI from 'pixi.js';\nimport { BaseGame } from './base-game';\nimport { randomInt, getAssetUrl } from '../utils';\n/**\n * Class representing a sliding puzzle game implementation\n */\nexport class PuzzleGame extends BaseGame {\n    /**\n     * Create a new PuzzleGame instance\n     *\n     * @param options - Game creation options\n     */\n    constructor(options) {\n        super(options.app, {\n            width: options.width,\n            height: options.height,\n            difficulty: options.difficulty,\n            backgroundColor: options.backgroundColor,\n            assetsPath: options.assetsPath,\n            onLoad: options.onLoad\n        });\n        /** Puzzle pieces */\n        this.pieces = [];\n        /** Empty cell position */\n        this.emptyCell = { row: 0, col: 0 };\n        /** Original image */\n        this.image = null;\n        /** Whether the puzzle is solved */\n        this.isSolved = false;\n        /** Number of moves made */\n        this.moveCount = 0;\n        /** Piece positions in solved state */\n        this.solvedPositions = [];\n        /** Piece metadata */\n        this.pieceMetadata = new Map();\n        // Set up puzzle specific options based on difficulty\n        this.puzzleConfig = {\n            rows: options.rows || this.getDifficultyBasedRows(),\n            columns: options.columns || this.getDifficultyBasedColumns(),\n            imageUrl: options.imageUrl || this.getDefaultImageUrl(),\n            shuffleMoves: options.shuffleMoves || this.getDifficultyBasedShuffleMoves()\n        };\n        this.rows = this.puzzleConfig.rows;\n        this.columns = this.puzzleConfig.columns;\n        // Set completion callback if provided\n        if (options.onComplete) {\n            this.setCompletionCallback(options.onComplete);\n        }\n        // Initialize the game\n        this.init();\n    }\n    /**\n     * Initialize the puzzle game\n     *\n     * @protected\n     */\n    initialize() {\n        // Create a loading message\n        const loadingText = new PIXI.Text('Loading puzzle...', {\n            fontFamily: 'Arial',\n            fontSize: 24,\n            fill: 0xffffff\n        });\n        loadingText.anchor.set(0.5);\n        loadingText.x = this.config.width / 2;\n        loadingText.y = this.config.height / 2;\n        this.container.addChild(loadingText);\n        // Load the puzzle image\n        PIXI.Assets.load(this.puzzleConfig.imageUrl)\n            .then(texture => {\n            // Remove loading text\n            this.container.removeChild(loadingText);\n            // Create the original image for reference\n            this.image = new PIXI.Sprite(texture);\n            this.image.width = this.config.width;\n            this.image.height = this.config.height;\n            // Create the puzzle pieces\n            this.createPuzzlePieces();\n            // Shuffle the puzzle\n            this.shufflePuzzle();\n            // Set up the game tick\n            this.app.ticker.add(this.update.bind(this));\n        })\n            .catch(error => {\n            console.error('Failed to load puzzle image:', error);\n            // Show error message\n            loadingText.text = 'Failed to load puzzle image!';\n            loadingText.style.fill = 0xff0000;\n        });\n    }\n    /**\n     * Create puzzle pieces from the loaded image\n     *\n     * @private\n     */\n    createPuzzlePieces() {\n        if (!this.image)\n            return;\n        const pieceWidth = this.config.width / this.columns;\n        const pieceHeight = this.config.height / this.rows;\n        // Store solved positions for later verification\n        this.solvedPositions = [];\n        // Create a container for pieces\n        const piecesContainer = new PIXI.Container();\n        this.container.addChild(piecesContainer);\n        // Create each piece\n        for (let row = 0; row < this.rows; row++) {\n            for (let col = 0; col < this.columns; col++) {\n                // Skip the last piece (will be empty)\n                if (row === this.rows - 1 && col === this.columns - 1) {\n                    this.emptyCell = { row, col };\n                    continue;\n                }\n                const piece = this.createPiece(row, col, pieceWidth, pieceHeight);\n                piecesContainer.addChild(piece);\n                // Store the piece\n                this.pieces.push(piece);\n                // Store the solved position\n                this.solvedPositions.push({\n                    x: col * pieceWidth,\n                    y: row * pieceHeight\n                });\n            }\n        }\n    }\n    /**\n     * Create a single puzzle piece\n     *\n     * @param row - Row position\n     * @param col - Column position\n     * @param width - Piece width\n     * @param height - Piece height\n     * @returns Puzzle piece sprite\n     * @private\n     */\n    createPiece(row, col, width, height) {\n        if (!this.image)\n            throw new Error('Image not loaded');\n        // Create a texture from a part of the original image\n        const texture = this.createPieceTexture(row, col, width, height);\n        // Create sprite from the texture\n        const piece = new PIXI.Sprite(texture);\n        // Position the piece\n        piece.x = col * width;\n        piece.y = row * height;\n        piece.width = width;\n        piece.height = height;\n        // Add interactivity\n        piece.eventMode = 'static';\n        piece.cursor = 'pointer';\n        piece.on('pointerdown', () => this.handlePieceClick(piece));\n        // Store metadata for the piece using a Map instead of directly on the sprite\n        this.pieceMetadata.set(piece, { row, col, originalIndex: row * this.columns + col });\n        return piece;\n    }\n    /**\n     * Create a texture for a puzzle piece from the main image\n     *\n     * @param row - Row position\n     * @param col - Column position\n     * @param width - Piece width\n     * @param height - Piece height\n     * @returns Texture for the piece\n     * @private\n     */\n    createPieceTexture(row, col, width, height) {\n        if (!this.image)\n            throw new Error('Image not loaded');\n        // For simplicity, create a new texture using a colored rectangle\n        // In a real implementation, we would properly slice the source image\n        const graphics = new PIXI.Graphics();\n        graphics.beginFill(this.getRandomColor());\n        graphics.drawRect(0, 0, width, height);\n        graphics.endFill();\n        // Add a number to identify the piece\n        const text = new PIXI.Text(`${row},${col}`, {\n            fontSize: 16,\n            fill: 0xffffff,\n        });\n        text.anchor.set(0.5);\n        text.position.set(width / 2, height / 2);\n        graphics.addChild(text);\n        // Generate texture from the graphics - using renderTexture in PIXI v8\n        const renderTexture = PIXI.RenderTexture.create({\n            width: width,\n            height: height\n        });\n        this.app.renderer.render(graphics, { renderTexture });\n        return renderTexture;\n    }\n    /**\n     * Get a random color for puzzle pieces\n     *\n     * @private\n     */\n    getRandomColor() {\n        const colors = [0x3498db, 0x2ecc71, 0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0xd35400];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n    /**\n     * Shuffle the puzzle by making random valid moves\n     *\n     * @private\n     */\n    shufflePuzzle() {\n        const moves = this.puzzleConfig.shuffleMoves;\n        // Make random moves\n        for (let i = 0; i < moves; i++) {\n            // Get neighbors of empty cell\n            const neighbors = this.getEmptyCellNeighbors();\n            // Pick a random neighbor to swap with empty cell\n            if (neighbors.length > 0) {\n                const randomIndex = Math.floor(Math.random() * neighbors.length);\n                this.swapWithEmptyCell(neighbors[randomIndex]);\n            }\n        }\n    }\n    /**\n     * Get pieces adjacent to the empty cell\n     *\n     * @returns Array of neighboring pieces\n     * @private\n     */\n    getEmptyCellNeighbors() {\n        const neighbors = [];\n        const { row, col } = this.emptyCell;\n        // Check each direction\n        const directions = [\n            { row: -1, col: 0 }, // up\n            { row: 1, col: 0 }, // down\n            { row: 0, col: -1 }, // left\n            { row: 0, col: 1 } // right\n        ];\n        for (const dir of directions) {\n            const newRow = row + dir.row;\n            const newCol = col + dir.col;\n            // If the new position is valid\n            if (newRow >= 0 && newRow < this.rows && newCol >= 0 && newCol < this.columns) {\n                // Find the piece at this position\n                const piece = this.findPieceAt(newRow, newCol);\n                if (piece) {\n                    neighbors.push(piece);\n                }\n            }\n        }\n        return neighbors;\n    }\n    /**\n     * Find a puzzle piece at a specific row and column\n     *\n     * @param row - Row position\n     * @param col - Column position\n     * @returns Puzzle piece at the position, or null if not found\n     * @private\n     */\n    findPieceAt(row, col) {\n        const pieceWidth = this.config.width / this.columns;\n        const pieceHeight = this.config.height / this.rows;\n        // Calculate expected position\n        const x = col * pieceWidth;\n        const y = row * pieceHeight;\n        // Find a piece close to this position\n        for (const piece of this.pieces) {\n            const closeX = Math.abs(piece.x - x) < 5;\n            const closeY = Math.abs(piece.y - y) < 5;\n            if (closeX && closeY) {\n                return piece;\n            }\n        }\n        return null;\n    }\n    /**\n     * Handle a click on a puzzle piece\n     *\n     * @param piece - Clicked puzzle piece\n     * @private\n     */\n    handlePieceClick(piece) {\n        if (!this.isRunning || this.isSolved)\n            return;\n        // Check if this piece is adjacent to the empty cell\n        const neighbors = this.getEmptyCellNeighbors();\n        if (neighbors.includes(piece)) {\n            // Swap piece with empty cell\n            this.swapWithEmptyCell(piece);\n            this.moveCount++;\n            // Check if puzzle is solved\n            if (this.checkPuzzleSolved()) {\n                this.isSolved = true;\n                this.handlePuzzleSolved();\n            }\n        }\n    }\n    /**\n     * Swap a piece with the empty cell\n     *\n     * @param piece - Piece to swap\n     * @private\n     */\n    swapWithEmptyCell(piece) {\n        // Get the piece metadata\n        const metadata = this.pieceMetadata.get(piece);\n        if (!metadata)\n            return;\n        // Store the piece position\n        const pieceX = piece.x;\n        const pieceY = piece.y;\n        // Calculate empty cell position\n        const emptyCellX = this.emptyCell.col * (this.config.width / this.columns);\n        const emptyCellY = this.emptyCell.row * (this.config.height / this.rows);\n        // Move the piece to the empty cell\n        piece.x = emptyCellX;\n        piece.y = emptyCellY;\n        // Update metadata for the piece\n        const oldRow = metadata.row;\n        const oldCol = metadata.col;\n        metadata.row = this.emptyCell.row;\n        metadata.col = this.emptyCell.col;\n        this.pieceMetadata.set(piece, metadata);\n        // Update empty cell to the piece's old position\n        this.emptyCell.row = oldRow;\n        this.emptyCell.col = oldCol;\n    }\n    /**\n     * Check if the puzzle is correctly solved\n     *\n     * @returns True if puzzle is solved\n     * @private\n     */\n    checkPuzzleSolved() {\n        // For each piece, check if it's in its original position\n        for (const piece of this.pieces) {\n            const metadata = this.pieceMetadata.get(piece);\n            if (!metadata)\n                continue;\n            // If this is the empty cell, continue\n            if (metadata.row === this.rows - 1 && metadata.col === this.columns - 1) {\n                continue;\n            }\n            // Check if the piece is in the correct position\n            if (metadata.row * this.columns + metadata.col !== metadata.originalIndex) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Handle the puzzle being solved\n     *\n     * @private\n     */\n    handlePuzzleSolved() {\n        // Calculate score based on time and moves\n        const timeFactor = Math.max(0, 1 - (Date.now() - this.startTime) / 60000); // 1 minute max\n        const movesFactor = Math.max(0, 1 - this.moveCount / (this.rows * this.columns * 3));\n        // Weight time more than moves\n        const score = Math.round((timeFactor * 0.7 + movesFactor * 0.3) * 100);\n        // Show success message\n        this.showSuccessMessage();\n        // Complete the game\n        this.complete(true, score, {\n            moves: this.moveCount,\n            time: Date.now() - this.startTime,\n            grid: `${this.rows}x${this.columns}`\n        });\n    }\n    /**\n     * Show success message when puzzle is completed\n     *\n     * @private\n     */\n    showSuccessMessage() {\n        // Create overlay\n        const overlay = new PIXI.Graphics();\n        overlay.beginFill(0x000000, 0.7);\n        overlay.drawRect(0, 0, this.config.width, this.config.height);\n        overlay.endFill();\n        this.container.addChild(overlay);\n        // Create success message\n        const message = new PIXI.Text('Puzzle Completed!', {\n            fontFamily: 'Arial',\n            fontSize: 32,\n            fill: 0xffffff,\n            align: 'center'\n        });\n        message.anchor.set(0.5);\n        message.x = this.config.width / 2;\n        message.y = this.config.height / 2;\n        this.container.addChild(message);\n        // Show additional stats\n        const stats = new PIXI.Text(`Moves: ${this.moveCount}\\nTime: ${((Date.now() - this.startTime) / 1000).toFixed(1)}s`, {\n            fontFamily: 'Arial',\n            fontSize: 20,\n            fill: 0xffffff,\n            align: 'center'\n        });\n        stats.anchor.set(0.5);\n        stats.x = this.config.width / 2;\n        stats.y = this.config.height / 2 + 60;\n        this.container.addChild(stats);\n    }\n    /**\n     * Update game state on each frame\n     *\n     * @param ticker - PIXI ticker\n     * @protected\n     */\n    update(ticker) {\n        const delta = ticker.deltaTime;\n        // In a full implementation, this would:\n        // - Apply any animations (like smooth piece movement)\n        // - Check for puzzle completion if moves were made\n        // - Update time and score displays\n        // For demo purposes, check if puzzle is solved\n        if (this.isRunning && !this.isSolved && this.checkPuzzleSolved()) {\n            this.handlePuzzleSolved();\n        }\n    }\n    /**\n     * Get rows based on difficulty\n     *\n     * @returns Number of rows\n     * @private\n     */\n    getDifficultyBasedRows() {\n        switch (this.config.difficulty) {\n            case 'easy': return 3;\n            case 'medium': return 4;\n            case 'hard': return 5;\n            default: return 4;\n        }\n    }\n    /**\n     * Get columns based on difficulty\n     *\n     * @returns Number of columns\n     * @private\n     */\n    getDifficultyBasedColumns() {\n        switch (this.config.difficulty) {\n            case 'easy': return 3;\n            case 'medium': return 4;\n            case 'hard': return 5;\n            default: return 4;\n        }\n    }\n    /**\n     * Get number of shuffle moves based on difficulty\n     *\n     * @returns Number of shuffle moves\n     * @private\n     */\n    getDifficultyBasedShuffleMoves() {\n        const baseMoves = this.rows * this.columns * 2;\n        switch (this.config.difficulty) {\n            case 'easy': return baseMoves;\n            case 'medium': return baseMoves * 2;\n            case 'hard': return baseMoves * 3;\n            default: return baseMoves * 2;\n        }\n    }\n    /**\n     * Get default image URL based on available assets\n     *\n     * @returns URL to the default puzzle image\n     * @private\n     */\n    getDefaultImageUrl() {\n        // Get a random image from the predefined set\n        const images = [\n            'puzzle1',\n            'puzzle2',\n            'puzzle3',\n            'puzzle4'\n        ];\n        const imageName = images[randomInt(0, images.length - 1)];\n        return getAssetUrl(imageName, 'jpg', this.config.assetsPath);\n    }\n}\n"],"names":["PuzzleGame","BaseGame","options","loadingText","PIXI.Text","PIXI.Assets","texture","PIXI.Sprite","error","pieceWidth","pieceHeight","piecesContainer","PIXI.Container","row","col","piece","width","height","graphics","PIXI.Graphics","text","renderTexture","PIXI.RenderTexture","colors","moves","i","neighbors","randomIndex","directions","dir","newRow","newCol","x","y","closeX","closeY","metadata","emptyCellX","emptyCellY","oldRow","oldCol","timeFactor","movesFactor","score","overlay","message","stats","ticker","baseMoves","images","imageName","randomInt","getAssetUrl"],"mappings":"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"}