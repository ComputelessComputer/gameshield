{"version":3,"file":"index357.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"],"sourcesContent":["import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[i];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n"],"names":["Resolver","bundleId","assetId","assetBundleId","bundleIdentifier","preferOrders","prefer","basePath","rootPath","searchParams","queryValues","key","asset","alias","src","convertToList","value","v","manifest","warn","bundle","assets","assetNames","convertedAssets","srcs","aliases","ids","bundleAssetId","bundleIds","name","keyCheck","data","format","loadParser","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","formattedAsset","i","parser","singleAsset","isSingleItem","out","results","result","keys","preferredOrder","priorityKey","filteredAssets","preferred","preference","url","paramConnector","assetData","path","getUrlExtension"],"mappings":"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","x_google_ignoreList":[0]}