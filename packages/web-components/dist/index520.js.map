{"version":3,"file":"index520.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"],"sourcesContent":["import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { parseSVGPath } from '../svg/parseSVGPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   * @param signed\n   */\n  constructor(instructions, signed = false) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    this.checkForHoles = signed;\n    if (typeof instructions === \"string\") {\n      parseSVGPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius || (innerRadius = radius / 2);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    newGraphicsPath2D.checkForHoles = this.checkForHoles;\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n"],"names":["GraphicsPath","instructions","signed","uid","parseSVGPath","ShapePath","path","transform","args","cp2x","cp2y","x","y","smoothness","last","lastPoint","Point","cp1x","cp1y","currentX","currentY","cpx1","cpy1","w","h","radius","points","innerRadius","rotation","startAngle","len","delta","polygon","i","r","angle","deep","newGraphicsPath2D","instruction","matrix","a","b","c","d","tx","ty","cpx2","cpy2","rx","ry","data","adjustTransform","warn","out","index","lastInstruction","currentMatrix"],"mappings":"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","x_google_ignoreList":[0]}