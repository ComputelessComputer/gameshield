{"version":3,"file":"index526.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"],"sourcesContent":["import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n    this.signed = graphicsPath2D.checkForHoles;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    const shapePrimitives = this.shapePrimitives;\n    const start = shapePrimitives.length;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    if (path.checkForHoles && shapePrimitives.length - start > 1) {\n      let mainShape = null;\n      for (let i = start; i < shapePrimitives.length; i++) {\n        const shapePrimitive = shapePrimitives[i];\n        if (shapePrimitive.shape.type === \"polygon\") {\n          const polygon = shapePrimitive.shape;\n          const mainPolygon = mainShape?.shape;\n          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {\n            mainShape.holes || (mainShape.holes = []);\n            mainShape.holes.push(shapePrimitive);\n            shapePrimitives.copyWithin(i, i + 1);\n            shapePrimitives.length--;\n            i--;\n          } else {\n            mainShape = shapePrimitive;\n          }\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = startAngle - i * delta;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n"],"names":["tempRectangle","Rectangle","ShapePath","graphicsPath2D","Bounds","x","y","points","fromX","fromY","radius","startAngle","endAngle","counterclockwise","buildArc","x1","y1","x2","y2","buildArcTo","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","buildArcToSvg","cp1x","cp1y","cp2x","cp2y","smoothness","currentPoly","buildAdaptiveBezier","smoothing","buildAdaptiveQuadratic","path","transform","shapePrimitives","start","i","instruction","mainShape","shapePrimitive","polygon","mainPolygon","closePath","w","h","Circle","close","Polygon","sides","rotation","delta","angle","corner","sideLength","internalAngle","x0","y0","a1","a2","x3","y3","useQuadratic","roundedShapeQuadraticCurve","roundedShapeArc","width","height","fillet","maxFillet","inset","right","bottom","dir","size","chamfer","radiusX","radiusY","Ellipse","RoundedRectangle","shape","matrix","lastShape","lx","ly","t","tempX","bounds","boundsRect"],"mappings":"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","x_google_ignoreList":[0]}