{"version":3,"file":"index415.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"],"sourcesContent":["import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n"],"names":["Batch","BatchTextureArray","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","batch","BATCH_TICK","_Batcher","options","uid","getMaxTexturesPerBatch","maxTextures","attributesInitialSize","indicesInitialSize","ViewableBuffer","i","batchableObject","texture","textureId","attributeBuffer","instructionSet","elements","textureBatch","firstElement","blendMode","getAdjustedBlendModeBlend","topology","f32","u32","indexBuffer","size","start","action","element","source","adjustedBlendMode","breakRequired","indexStart","indexSize","newSize","newArrayBuffer","fastCopy","newIndexBuffer","index","indicesOffset","indices","indexOffset","attributeOffset","Batcher"],"mappings":"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","x_google_ignoreList":[0]}