{"version":3,"file":"index502.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"],"sourcesContent":["import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n"],"names":["RECURSION_LIMIT","FLT_EPSILON","PATH_DISTANCE_EPSILON","buildAdaptiveBezier","points","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","smoothing","GraphicsContextSystem","distanceTolerance","begin","recursive","x1","y1","x2","y2","x3","y3","x4","y4","level","x12","y12","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","dx","dy","d2","d3"],"mappings":";AAGA,MAAMA,IAAkB,GAClBC,IAAc,cACdC,IAAwB;AAI9B,SAASC,EAAoBC,GAAQC,GAAIC,GAAIC,GAAMC,GAAMC,GAAMC,GAAMC,GAAIC,GAAIC,GAAY;AAEvF,QAAMC,IAAY,KAAK;AAAA,IACrB;AAAA;AAAA,IAEA,KAAK,IAAI,GAAGD,KAAcE,EAAsB,eAAe,gBAAgB;AAAA,EACnF;AACE,MAAIC,KAAqBd,IAAwBY,KAAa;AAC9D,SAAAE,KAAqBA,GACrBC,EAAMZ,GAAIC,GAAIC,GAAMC,GAAMC,GAAMC,GAAMC,GAAIC,GAAIR,GAAQY,CAAiB,GAChEZ;AACT;AACA,SAASa,EAAMZ,GAAIC,GAAIC,GAAMC,GAAMC,GAAMC,GAAMC,GAAIC,GAAIR,GAAQY,GAAmB;AAChF,EAAAE,EAAUb,GAAIC,GAAIC,GAAMC,GAAMC,GAAMC,GAAMC,GAAIC,GAAIR,GAAQY,GAAmB,CAAC,GAC9EZ,EAAO,KAAKO,GAAIC,CAAE;AACpB;AACA,SAASM,EAAUC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAItB,GAAQY,GAAmBW,GAAO;AACnF,MAAIA,IAAQ3B;AACV;AAGF,QAAM4B,KAAOT,IAAKE,KAAM,GAClBQ,KAAOT,IAAKE,KAAM,GAClBQ,KAAOT,IAAKE,KAAM,GAClBQ,KAAOT,IAAKE,KAAM,GAClBQ,KAAOT,IAAKE,KAAM,GAClBQ,KAAOT,IAAKE,KAAM,GAClBQ,KAAQN,IAAME,KAAO,GACrBK,KAAQN,IAAME,KAAO,GACrBK,KAAQN,IAAME,KAAO,GACrBK,KAAQN,IAAME,KAAO,GACrBK,KAASJ,IAAOE,KAAQ,GACxBG,KAASJ,IAAOE,KAAQ;AAC9B,MAAIV,IAAQ,GAAG;AACb,QAAIa,IAAKf,IAAKN,GACVsB,IAAKf,IAAKN;AACd,UAAMsB,IAAK,KAAK,KAAKrB,IAAKI,KAAMgB,KAAMnB,IAAKI,KAAMc,CAAE,GAC7CG,IAAK,KAAK,KAAKpB,IAAKE,KAAMgB,KAAMjB,IAAKE,KAAMc,CAAE;AAGnD,QAAIE,IAAKzC,KAAe0C,IAAK1C;AAC3B,WAAKyC,IAAKC,MAAOD,IAAKC,MAAO3B,KAAqBwB,IAAKA,IAAKC,IAAKA,IACb;AAChD,QAAArC,EAAO,KAAKkC,GAAOC,CAAK;AACxB;AAAA,MACD;AAAA,eAuBMG,IAAKzC;AACd,UAAIyC,IAAKA,KAAM1B,KAAqBwB,IAAKA,IAAKC,IAAKA,IACC;AAChD,QAAArC,EAAO,KAAKkC,GAAOC,CAAK;AACxB;AAAA,MACD;AAAA,eAgBMI,IAAK1C;AACd,UAAI0C,IAAKA,KAAM3B,KAAqBwB,IAAKA,IAAKC,IAAKA,IACC;AAChD,QAAArC,EAAO,KAAKkC,GAAOC,CAAK;AACxB;AAAA,MACD;AAAA,eAiBHC,IAAKF,KAASnB,IAAKM,KAAM,GACzBgB,IAAKF,KAASnB,IAAKM,KAAM,GACrBc,IAAKA,IAAKC,IAAKA,KAAMzB,GAAmB;AAC1C,MAAAZ,EAAO,KAAKkC,GAAOC,CAAK;AACxB;AAAA,IACD;AAAA,EAEJ;AACD,EAAArB,EAAUC,GAAIC,GAAIQ,GAAKC,GAAKK,GAAMC,GAAMG,GAAOC,GAAOnC,GAAQY,GAAmBW,IAAQ,CAAC,GAC1FT,EAAUoB,GAAOC,GAAOH,GAAMC,GAAML,GAAKC,GAAKR,GAAIC,GAAItB,GAAQY,GAAmBW,IAAQ,CAAC;AAC5F;","x_google_ignoreList":[0]}