{"version":3,"file":"index354.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc || (loc = globalThis.location);\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    name: \"loadVideo\"\n  },\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };\n//# sourceMappingURL=loadVideoTextures.mjs.map\n"],"names":["validVideoExtensions","validVideoMIMEs","ext","crossOrigin","element","url","crossorigin","determineCrossOrigin","preloadVideo","resolve","reject","loaded","error","cleanup","err","loc","parsedUrl","loadVideoTextures","ExtensionType","isValidDataUrl","checkDataUrl","isValidExtension","checkExtension","asset","loader","options","VideoSource","_a","getResolutionOfUrl","_b","detectVideoAlphaMode","videoElement","attributeMap","key","value","sourceElement","mime","onCanPlay","base","createTexture","texture"],"mappings":"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","x_google_ignoreList":[0]}