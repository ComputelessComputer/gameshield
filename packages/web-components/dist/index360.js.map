{"version":3,"file":"index360.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferImageSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n   */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n"],"names":["Texture","EventEmitter","source","label","frame","orig","trim","defaultAnchor","defaultBorders","rotate","dynamic","uid","Rectangle","TextureSource","width","height","value","TextureMatrix","uvs","nX","nY","nW","nH","w2","h2","cX","cY","groupD8","destroySource","deprecation","v8_0_0","NOOP","BufferImageSource"],"mappings":"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","x_google_ignoreList":[0]}