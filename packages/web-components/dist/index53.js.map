{"version":3,"file":"index53.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/filters/FilterSystem.mjs"],"sourcesContent":["import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from \"@pixi/constants\";\nimport { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { Point, Matrix, Rectangle } from \"@pixi/math\";\nimport { RenderTexturePool } from \"../renderTexture/RenderTexturePool.mjs\";\nimport { UniformGroup } from \"../shader/UniformGroup.mjs\";\nimport { Quad } from \"../utils/Quad.mjs\";\nimport { QuadUv } from \"../utils/QuadUv.mjs\";\nimport { FilterState } from \"./FilterState.mjs\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix = new Matrix();\nclass FilterSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      // legacy variables\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n   * input render-texture for the rest of the filtering pipeline.\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param filters - The filters to apply.\n   */\n  push(target, filters) {\n    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), renderTextureSystem = renderer.renderTexture;\n    let currentResolution, currentMultisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;\n    } else\n      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;\n    let resolution = filters[0].resolution || currentResolution, multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? !0;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? !0);\n    }\n    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    renderer.projection.transform && this.transformAABB(\n      tempMatrix.copyFrom(renderer.projection.transform).invert(),\n      sourceFrameProjected\n    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(\n      state.sourceFrame,\n      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n      renderTextureSystem.sourceFrame,\n      renderTextureSystem.destinationFrame,\n      renderer.projection.transform\n    ), state.renderTexture = this.getOptimalFilterTexture(\n      state.sourceFrame.width,\n      state.sourceFrame.height,\n      resolution,\n      multisample\n    ), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /** Pops off the filter and applies it. */\n  pop() {\n    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;\n    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    if (this.renderer.framebuffer.blit(), filters.length === 1)\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);\n    else {\n      let flip = state.renderTexture, flop = this.getOptimalFilterTexture(\n        flip.width,\n        flip.height,\n        state.resolution\n      );\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        i === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(\n          flip.width,\n          flip.height,\n          state.resolution\n        ), flop.filterFrame = flip.filterFrame), filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n        const t = flip;\n        flip = flop, flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state), i > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);\n    }\n    state.clear(), this.statePool.push(state);\n  }\n  /**\n   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n   */\n  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else\n      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(\n        filterTexture,\n        this.activeState.bindingSourceFrame,\n        this.activeState.bindingDestinationFrame\n      );\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /**\n   * Draws a filter using the default rendering process.\n   *\n   * This should be called only by {@link PIXI.Filter#apply}.\n   * @param filter - The filter to draw.\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(\n      destinationFrame.width,\n      0,\n      0,\n      destinationFrame.height,\n      sourceFrame.x,\n      sourceFrame.y\n    ), worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;\n  }\n  /** Destroys this Filter System. */\n  destroy() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture in real pixels.\n   * @param minHeight - The minimum height of the render texture in real pixels.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns - The new render texture.\n   */\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  /**\n   * Gets extra render texture to use inside current filter\n   * To be compliant with older filters, you can use params in any order\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input == \"number\") {\n      const swap = input;\n      input = resolution, resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(\n      input.width,\n      input.height,\n      resolution || input.resolution,\n      multisample || MSAA_QUALITY.NONE\n    );\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Frees a render texture back into the pool.\n   * @param renderTexture - The renderTarget to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  /** Empties the texture pool. */\n  emptyPool() {\n    this.texturePool.clear(!0);\n  }\n  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * @param matrix - first param\n   * @param rect - second param\n   */\n  transformAABB(matrix, rect) {\n    const lt = tempPoints[0], lb = tempPoints[1], rt = tempPoints[2], rb = tempPoints[3];\n    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {\n      if (transform) {\n        const { a, b, c, d } = transform;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n          return;\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(\n        bindingDestinationFrame.width / bindingSourceFrame.width,\n        bindingDestinationFrame.height / bindingSourceFrame.height\n      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);\n    }\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.add(FilterSystem);\nexport {\n  FilterSystem\n};\n//# sourceMappingURL=FilterSystem.mjs.map\n"],"names":["tempPoints","Point","tempMatrix","Matrix","FilterSystem","renderer","RenderTexturePool","Quad","QuadUv","Rectangle","UniformGroup","target","filters","filterStack","state","FilterState","renderTextureSystem","currentResolution","currentMultisample","renderTexture","resolution","multisample","padding","autoFit","legacy","i","filter","sourceFrameProjected","destinationFrame","globalUniforms","inputSize","inputPixel","inputClamp","filterArea","lastState","CLEAR_MODES","flip","flop","t","filterTexture","clearMode","stateSystem","autoClear","input","output","DRAW_MODES","outputMatrix","sprite","sourceFrame","orig","mappedMatrix","worldTransform","minWidth","minHeight","MSAA_QUALITY","swap","matrix","rect","lt","lb","rt","rb","x0","y0","x1","y1","frame","bindingSourceFrame","bindingDestinationFrame","transform","b","c","d","ExtensionType","extensions"],"mappings":"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","x_google_ignoreList":[0]}