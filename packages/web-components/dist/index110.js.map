{"version":3,"file":"index110.js","sources":["../../../node_modules/.pnpm/@pixi+mesh@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3_/node_modules/@pixi/mesh/lib/Mesh.mjs"],"sourcesContent":["import { Point, Polygon, State, settings, DRAW_MODES } from \"@pixi/core\";\nimport { Container } from \"@pixi/display\";\nimport { MeshBatchUvs } from \"./MeshBatchUvs.mjs\";\nconst tempPoint = new Point(), tempPolygon = new Polygon(), _Mesh = class _Mesh2 extends Container {\n  /**\n   * @param geometry - The geometry the mesh will use.\n   * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n   * @param state - The state that the WebGL context is required to be in to render the mesh\n   *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n   * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n   */\n  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {\n    super(), this.geometry = geometry, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null;\n  }\n  /**\n   * Includes vertex positions, face indices, normals, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh objects.\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  set geometry(value) {\n    this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n  }\n  /**\n   * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n   * @readonly\n   */\n  get uvBuffer() {\n    return this.geometry.buffers[1];\n  }\n  /**\n   * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n   * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n   * @readonly\n   */\n  get verticesBuffer() {\n    return this.geometry.buffers[0];\n  }\n  /** Alias for {@link PIXI.Mesh#shader}. */\n  set material(value) {\n    this.shader = value;\n  }\n  get material() {\n    return this.shader;\n  }\n  /**\n   * The blend mode to be applied to the Mesh. Apply a value of\n   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n   * @default PIXI.BLEND_MODES.NORMAL;\n   */\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n   * @default false\n   */\n  set roundPixels(value) {\n    this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  /**\n   * The multiply tint applied to the Mesh. This is a hex value. A value of\n   * `0xFFFFFF` will remove any tint effect.\n   *\n   * Null for non-MeshMaterial shaders\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return \"tint\" in this.shader ? this.shader.tint : null;\n  }\n  set tint(value) {\n    this.shader.tint = value;\n  }\n  /**\n   * The tint color as a RGB integer\n   * @ignore\n   */\n  get tintValue() {\n    return this.shader.tintValue;\n  }\n  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n  get texture() {\n    return \"texture\" in this.shader ? this.shader.texture : null;\n  }\n  set texture(value) {\n    this.shader.texture = value;\n  }\n  /**\n   * Standard renderer draw.\n   * @param renderer - Instance to renderer.\n   */\n  _render(renderer) {\n    const vertices = this.geometry.buffers[0].data;\n    this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);\n  }\n  /**\n   * Standard non-batching way of rendering.\n   * @param renderer - Instance to renderer.\n   */\n  _renderDefault(renderer) {\n    const shader = this.shader;\n    shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }\n  /**\n   * Rendering by using the Batch system.\n   * @param renderer - Instance to renderer.\n   */\n  _renderToBatch(renderer) {\n    const geometry = this.geometry, shader = this.shader;\n    shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;\n    const pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);\n  }\n  /** Updates vertexData field based on transform and vertices. */\n  calculateVertices() {\n    const verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data, vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n      return;\n    this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData;\n    for (let i = 0; i < vertexData.length / 2; i++) {\n      const x = vertices[i * 2], y = vertices[i * 2 + 1];\n      vertexData[i * 2] = a * x + c * y + tx, vertexData[i * 2 + 1] = b * x + d * y + ty;\n    }\n    if (this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n    this.vertexDirty = vertexDirtyId;\n  }\n  /** Updates uv field based on from geometry uv's or batchUvs. */\n  calculateUvs() {\n    const geomUvs = this.geometry.buffers[1], shader = this.shader;\n    shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n  }\n  /**\n   * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n   * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n   */\n  _calculateBounds() {\n    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }\n  /**\n   * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n   * @param point - The point to test.\n   * @returns - The result of the test.\n   */\n  containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y))\n      return !1;\n    this.worldTransform.applyInverse(point, tempPoint);\n    const vertices = this.geometry.getBuffer(\"aVertexPosition\").data, points = tempPolygon.points, indices = this.geometry.getIndex().data, len = indices.length, step = this.drawMode === 4 ? 3 : 1;\n    for (let i = 0; i + 2 < len; i += step) {\n      const ind0 = indices[i] * 2, ind1 = indices[i + 1] * 2, ind2 = indices[i + 2] * 2;\n      if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))\n        return !0;\n    }\n    return !1;\n  }\n  destroy(options) {\n    super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n  }\n};\n_Mesh.BATCHABLE_SIZE = 100;\nlet Mesh = _Mesh;\nexport {\n  Mesh\n};\n//# sourceMappingURL=Mesh.mjs.map\n"],"names":["tempPoint","Point","tempPolygon","Polygon","_Mesh","_Mesh2","Container","geometry","shader","state","drawMode","DRAW_MODES","State","settings","value","renderer","vertices","pluginName","verticesBuffer","vertexDirtyId","wt","a","b","c","d","tx","ty","vertexData","i","x","y","resolution","geomUvs","MeshBatchUvs","point","points","indices","len","step","ind0","ind1","ind2","options","Mesh"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,MAAMA,IAAY,IAAIC,EAAO,GAAEC,IAAc,IAAIC,EAAO,GAAIC,IAAQ,MAAMC,UAAeC,EAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQjG,YAAYC,GAAUC,GAAQC,GAAOC,IAAWC,EAAW,WAAW;AACpE,aAAS,KAAK,WAAWJ,GAAU,KAAK,SAASC,GAAQ,KAAK,QAAQC,KAASG,EAAM,MAAK,GAAI,KAAK,WAAWF,GAAU,KAAK,QAAQ,GAAG,KAAK,OAAO,GAAG,KAAK,MAAM,MAAM,KAAK,UAAU,MAAM,KAAK,aAAa,IAAI,aAAa,CAAC,GAAG,KAAK,cAAc,IAAI,KAAK,eAAe,IAAI,KAAK,eAAeG,EAAS,cAAc,KAAK,WAAW;AAAA,EAC/U;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,SAASC,GAAO;AAClB,SAAK,cAAcA,MAAU,KAAK,cAAc,KAAK,UAAU,YAAY,KAAK,UAAU,aAAa,KAAK,KAAK,UAAU,QAAO,IAAK,KAAK,YAAYA,GAAO,KAAK,aAAa,KAAK,UAAU,YAAY,KAAK,cAAc;AAAA,EAChO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,WAAW;AACb,WAAO,KAAK,SAAS,QAAQ,CAAC;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,IAAI,iBAAiB;AACnB,WAAO,KAAK,SAAS,QAAQ,CAAC;AAAA,EAC/B;AAAA;AAAA,EAED,IAAI,SAASA,GAAO;AAClB,SAAK,SAASA;AAAA,EACf;AAAA,EACD,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,IAAI,UAAUA,GAAO;AACnB,SAAK,MAAM,YAAYA;AAAA,EACxB;AAAA,EACD,IAAI,YAAY;AACd,WAAO,KAAK,MAAM;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,IAAI,YAAYA,GAAO;AACrB,SAAK,iBAAiBA,MAAU,KAAK,eAAe,KAAK,KAAK,eAAeA;AAAA,EAC9E;AAAA,EACD,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,IAAI,OAAO;AACT,WAAO,UAAU,KAAK,SAAS,KAAK,OAAO,OAAO;AAAA,EACnD;AAAA,EACD,IAAI,KAAKA,GAAO;AACd,SAAK,OAAO,OAAOA;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,YAAY;AACd,WAAO,KAAK,OAAO;AAAA,EACpB;AAAA;AAAA,EAED,IAAI,UAAU;AACZ,WAAO,aAAa,KAAK,SAAS,KAAK,OAAO,UAAU;AAAA,EACzD;AAAA,EACD,IAAI,QAAQA,GAAO;AACjB,SAAK,OAAO,UAAUA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,QAAQC,GAAU;AAChB,UAAMC,IAAW,KAAK,SAAS,QAAQ,CAAC,EAAE;AAC1C,SAAK,OAAO,aAAa,KAAK,aAAaL,EAAW,aAAaK,EAAS,SAASX,EAAO,iBAAiB,IAAI,KAAK,eAAeU,CAAQ,IAAI,KAAK,eAAeA,CAAQ;AAAA,EAC9K;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,eAAeA,GAAU;AACvB,UAAMP,IAAS,KAAK;AACpB,IAAAA,EAAO,QAAQ,KAAK,YAAYA,EAAO,UAAUA,EAAO,OAAM,GAAIO,EAAS,MAAM,MAAK,GAAIP,EAAO,SAAS,oBAAoB,KAAK,UAAU,eAAe,QAAQ,EAAE,GAAGO,EAAS,OAAO,KAAKP,CAAM,GAAGO,EAAS,MAAM,IAAI,KAAK,KAAK,GAAGA,EAAS,SAAS,KAAK,KAAK,UAAUP,CAAM,GAAGO,EAAS,SAAS,KAAK,KAAK,UAAU,KAAK,MAAM,KAAK,OAAO,KAAK,SAAS,aAAa;AAAA,EAC/W;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,eAAeA,GAAU;AACvB,UAAMR,IAAW,KAAK,UAAUC,IAAS,KAAK;AAC9C,IAAAA,EAAO,aAAaA,EAAO,SAAS,OAAM,GAAI,KAAK,aAAc,IAAG,KAAK,kBAAiB,GAAI,KAAK,UAAUD,EAAS,YAAY,MAAM,KAAK,WAAWC,EAAO,UAAU,KAAK,WAAWA,EAAO;AAChM,UAAMS,IAAa,KAAK,SAAS;AACjC,IAAAF,EAAS,MAAM,kBAAkBA,EAAS,QAAQE,CAAU,CAAC,GAAGF,EAAS,QAAQE,CAAU,EAAE,OAAO,IAAI;AAAA,EACzG;AAAA;AAAA,EAED,oBAAoB;AAClB,UAAMC,IAAiB,KAAK,SAAS,QAAQ,CAAC,GAAGF,IAAWE,EAAe,MAAMC,IAAgBD,EAAe;AAChH,QAAIC,MAAkB,KAAK,eAAe,KAAK,iBAAiB,KAAK,UAAU;AAC7E;AACF,SAAK,eAAe,KAAK,UAAU,UAAU,KAAK,WAAW,WAAWH,EAAS,WAAW,KAAK,aAAa,IAAI,aAAaA,EAAS,MAAM;AAC9I,UAAMI,IAAK,KAAK,UAAU,gBAAgBC,IAAID,EAAG,GAAGE,IAAIF,EAAG,GAAGG,IAAIH,EAAG,GAAGI,IAAIJ,EAAG,GAAGK,IAAKL,EAAG,IAAIM,IAAKN,EAAG,IAAIO,IAAa,KAAK;AAC5H,aAASC,IAAI,GAAGA,IAAID,EAAW,SAAS,GAAGC,KAAK;AAC9C,YAAMC,IAAIb,EAASY,IAAI,CAAC,GAAGE,IAAId,EAASY,IAAI,IAAI,CAAC;AACjD,MAAAD,EAAWC,IAAI,CAAC,IAAIP,IAAIQ,IAAIN,IAAIO,IAAIL,GAAIE,EAAWC,IAAI,IAAI,CAAC,IAAIN,IAAIO,IAAIL,IAAIM,IAAIJ;AAAA,IACjF;AACD,QAAI,KAAK,cAAc;AACrB,YAAMK,IAAalB,EAAS;AAC5B,eAASe,IAAI,GAAGA,IAAID,EAAW,QAAQ,EAAEC;AACvC,QAAAD,EAAWC,CAAC,IAAI,KAAK,MAAMD,EAAWC,CAAC,IAAIG,CAAU,IAAIA;AAAA,IAC5D;AACD,SAAK,cAAcZ;AAAA,EACpB;AAAA;AAAA,EAED,eAAe;AACb,UAAMa,IAAU,KAAK,SAAS,QAAQ,CAAC,GAAGxB,IAAS,KAAK;AACxD,IAAAA,EAAO,SAAS,WAAW,KAAK,MAAMwB,EAAQ,QAAQ,KAAK,aAAa,KAAK,WAAW,IAAIC,EAAaD,GAASxB,EAAO,QAAQ,IAAI,KAAK,SAAS,UAAU,KAAK,MAAM,KAAK,SAAS;AAAA,EACvL;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,mBAAmB;AACjB,SAAK,kBAAiB,GAAI,KAAK,QAAQ,cAAc,KAAK,YAAY,GAAG,KAAK,WAAW,MAAM;AAAA,EAChG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,cAAc0B,GAAO;AACnB,QAAI,CAAC,KAAK,YAAY,SAASA,EAAM,GAAGA,EAAM,CAAC;AAC7C,aAAO;AACT,SAAK,eAAe,aAAaA,GAAOlC,CAAS;AACjD,UAAMgB,IAAW,KAAK,SAAS,UAAU,iBAAiB,EAAE,MAAMmB,IAASjC,EAAY,QAAQkC,IAAU,KAAK,SAAS,WAAW,MAAMC,IAAMD,EAAQ,QAAQE,IAAO,KAAK,aAAa,IAAI,IAAI;AAC/L,aAASV,IAAI,GAAGA,IAAI,IAAIS,GAAKT,KAAKU,GAAM;AACtC,YAAMC,IAAOH,EAAQR,CAAC,IAAI,GAAGY,IAAOJ,EAAQR,IAAI,CAAC,IAAI,GAAGa,IAAOL,EAAQR,IAAI,CAAC,IAAI;AAChF,UAAIO,EAAO,CAAC,IAAInB,EAASuB,CAAI,GAAGJ,EAAO,CAAC,IAAInB,EAASuB,IAAO,CAAC,GAAGJ,EAAO,CAAC,IAAInB,EAASwB,CAAI,GAAGL,EAAO,CAAC,IAAInB,EAASwB,IAAO,CAAC,GAAGL,EAAO,CAAC,IAAInB,EAASyB,CAAI,GAAGN,EAAO,CAAC,IAAInB,EAASyB,IAAO,CAAC,GAAGvC,EAAY,SAASF,EAAU,GAAGA,EAAU,CAAC;AACnO,eAAO;AAAA,IACV;AACD,WAAO;AAAA,EACR;AAAA,EACD,QAAQ0C,GAAS;AACf,UAAM,QAAQA,CAAO,GAAG,KAAK,mBAAmB,KAAK,eAAe,QAAS,GAAE,KAAK,iBAAiB,OAAO,KAAK,WAAW,MAAM,KAAK,SAAS,MAAM,KAAK,QAAQ,MAAM,KAAK,MAAM,MAAM,KAAK,UAAU,MAAM,KAAK,aAAa;AAAA,EAClO;AACH;AACAtC,EAAM,iBAAiB;AACpB,IAACuC,KAAOvC;","x_google_ignoreList":[0]}