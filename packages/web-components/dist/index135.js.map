{"version":3,"file":"index135.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/textures/Texture.mjs"],"sourcesContent":["import { Rectangle, Point } from \"@pixi/math\";\nimport { settings } from \"@pixi/settings\";\nimport { EventEmitter, TextureCache, uid, getResolutionOfUrl } from \"@pixi/utils\";\nimport { BaseTexture } from \"./BaseTexture.mjs\";\nimport { ImageResource } from \"./resources/ImageResource.mjs\";\nimport { TextureUvs } from \"./TextureUvs.mjs\";\nconst DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function() {\n  }, tex.on = function() {\n  }, tex.once = function() {\n  }, tex.emit = function() {\n  };\n}\nclass Texture extends EventEmitter {\n  /**\n   * @param baseTexture - The base texture source to create the texture from\n   * @param frame - The rectangle frame of the texture to show\n   * @param orig - The area of original texture\n   * @param trim - Trimmed rectangle of original texture\n   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}\n   * @param anchor - Default anchor point used for sprite placement / rotation\n   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}\n   */\n  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {\n    if (super(), this.noFrame = !1, frame || (this.noFrame = !0, frame = new Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.destroyed = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === !0)\n      this._rotate = 2;\n    else if (this._rotate % 2 !== 0)\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once(\"loaded\", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on(\"update\", this.onBaseTextureUpdated, this);\n  }\n  /**\n   * Updates this texture on the gpu.\n   *\n   * Calls the TextureResource update.\n   *\n   * If you adjusted `frame` manually, please call `updateUvs()` instead.\n   */\n  update() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }\n  /**\n   * Called when the base texture is updated\n   * @protected\n   * @param baseTexture - The base texture.\n   */\n  onBaseTextureUpdated(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Destroys this texture\n   * @param [destroyBase=false] - Whether to destroy the base texture as well\n   * @fires PIXI.Texture#destroyed\n   */\n  destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        const { resource } = this.baseTexture;\n        resource?.url && TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit(\"destroyed\", this), this.removeAllListeners();\n  }\n  /**\n   * Creates a new texture object that acts the same as this one.\n   * @returns - The new texture\n   */\n  clone() {\n    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture(\n      this.baseTexture,\n      !this.noFrame && clonedFrame,\n      clonedOrig,\n      this.trim?.clone(),\n      this.rotate,\n      this.defaultAnchor,\n      this.defaultBorders\n    );\n    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;\n  }\n  /**\n   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n   * Call it after changing the frame\n   */\n  updateUvs() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }\n  /**\n   * Helper function that creates a new Texture based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -\n   *        Source or array of sources to create texture from\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.Texture} The newly created texture\n   */\n  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == \"string\";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else if (source instanceof BaseTexture) {\n      if (!source.cacheId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source.cacheId = `${prefix}-${uid()}`, BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source._pixiId = `${prefix}_${uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let texture = TextureCache[cacheId];\n    if (isFrame && strict && !texture)\n      throw new Error(`The cacheId \"${cacheId}\" does not exist in TextureCache.`);\n    return !texture && !(source instanceof BaseTexture) ? (options.resolution || (options.resolution = getResolutionOfUrl(source)), texture = new Texture(new BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)) : !texture && source instanceof BaseTexture && (texture = new Texture(source), Texture.addToCache(texture, cacheId)), texture;\n  }\n  /**\n   * Useful for loading textures via URLs. Use instead of `Texture.from` because\n   * it does a better job of handling failed URLs more effectively. This also ignores\n   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.\n   * @param url - The remote URL or array of URLs to load.\n   * @param options - Optional options to include\n   * @returns - A Promise that resolves to a Texture.\n   */\n  static fromURL(url, options) {\n    const resourceOptions = Object.assign({ autoLoad: !1 }, options?.resourceOptions), texture = Texture.from(url, Object.assign({ resourceOptions }, options), !1), resource = texture.baseTexture.resource;\n    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   *        Default properties are different from the constructor's defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));\n  }\n  /**\n   * Create a texture from a source and add to the cache.\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.\n   * @param imageUrl - File name of texture, for cache and resolving resolution.\n   * @param name - Human readable name for the texture cache. If no name is\n   *        specified, only `imageUrl` will be used as the cache ID.\n   * @param options\n   * @returns - Output texture\n   */\n  static fromLoader(source, imageUrl, name, options) {\n    const baseTexture = new BaseTexture(source, Object.assign({\n      scaleMode: BaseTexture.defaultOptions.scaleMode,\n      resolution: getResolutionOfUrl(imageUrl)\n    }, options)), { resource } = baseTexture;\n    resource instanceof ImageResource && (resource.url = imageUrl);\n    const texture = new Texture(baseTexture);\n    return name || (name = imageUrl), BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve) => {\n      texture.baseTexture.once(\"loaded\", () => resolve(texture));\n    });\n  }\n  /**\n   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n   * @param texture - The Texture to add to the cache.\n   * @param id - The id that the Texture will be stored against.\n   */\n  static addToCache(texture, id) {\n    id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), TextureCache[id] && TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), TextureCache[id] = texture);\n  }\n  /**\n   * Remove a Texture from the global TextureCache.\n   * @param texture - id of a Texture to be removed, or a Texture instance itself\n   * @returns - The Texture that was removed\n   */\n  static removeFromCache(texture) {\n    if (typeof texture == \"string\") {\n      const textureFromCache = TextureCache[texture];\n      if (textureFromCache) {\n        const index = textureFromCache.textureCacheIds.indexOf(texture);\n        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache;\n      }\n    } else if (texture?.textureCacheIds) {\n      for (let i = 0; i < texture.textureCacheIds.length; ++i)\n        TextureCache[texture.textureCacheIds[i]] === texture && delete TextureCache[texture.textureCacheIds[i]];\n      return texture.textureCacheIds.length = 0, texture;\n    }\n    return null;\n  }\n  /**\n   * Returns resolution of baseTexture\n   * @readonly\n   */\n  get resolution() {\n    return this.baseTexture.resolution;\n  }\n  /**\n   * The frame specifies the region of the base texture that this texture uses.\n   * Please call `updateUvs()` after you change coordinates of `frame` manually.\n   */\n  get frame() {\n    return this._frame;\n  }\n  set frame(frame) {\n    this._frame = frame, this.noFrame = !1;\n    const { x, y, width, height } = frame, xNotFit = x + width > this.baseTexture.width, yNotFit = y + height > this.baseTexture.height;\n    if (xNotFit || yNotFit) {\n      const relationship = xNotFit && yNotFit ? \"and\" : \"or\", errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`, errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);\n    }\n    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();\n  }\n  /**\n   * Indicates whether the texture is rotated inside the atlas\n   * set to 2 to compensate for texture packer rotation\n   * set to 6 to compensate for spine packer rotation\n   * can be used to rotate or mirror sprites\n   * See {@link PIXI.groupD8} for explanation\n   */\n  get rotate() {\n    return this._rotate;\n  }\n  set rotate(rotate) {\n    this._rotate = rotate, this.valid && this.updateUvs();\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this.baseTexture;\n  }\n  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */\n  static get EMPTY() {\n    return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;\n  }\n  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */\n  static get WHITE() {\n    if (!Texture._WHITE) {\n      const canvas = settings.ADAPTER.createCanvas(16, 16), context = canvas.getContext(\"2d\");\n      canvas.width = 16, canvas.height = 16, context.fillStyle = \"white\", context.fillRect(0, 0, 16, 16), Texture._WHITE = new Texture(BaseTexture.from(canvas)), removeAllHandlers(Texture._WHITE), removeAllHandlers(Texture._WHITE.baseTexture);\n    }\n    return Texture._WHITE;\n  }\n}\nexport {\n  Texture\n};\n//# sourceMappingURL=Texture.mjs.map\n"],"names":["DEFAULT_UVS","TextureUvs","removeAllHandlers","tex","Texture","EventEmitter","baseTexture","frame","orig","trim","rotate","anchor","borders","Rectangle","Point","destroyBase","resource","TextureCache","clonedFrame","clonedOrig","clonedTexture","_a","source","options","strict","settings","isFrame","cacheId","BaseTexture","prefix","uid","texture","getResolutionOfUrl","url","resourceOptions","buffer","width","height","imageUrl","name","ImageResource","resolve","id","textureFromCache","index","i","x","y","xNotFit","yNotFit","relationship","errorX","errorY","canvas","context"],"mappings":"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","x_google_ignoreList":[0]}