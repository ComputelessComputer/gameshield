{"version":3,"file":"index431.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /** A unique identifier for the shader */\n    this.uid = uid(\"shader\");\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n"],"names":["Shader","EventEmitter","options","uid","gpuProgram","glProgram","groups","resources","compatibleRenderers","groupMap","RendererType","nameHash","i","j","uniformName","groupData","data","bindTick","BindGroup","name","value","UniformGroup","groupIndex","bindIndex","_a","_b","uniformsOut","destroyPrograms","bindGroup","gpu","gl","rest","GpuProgram","GlProgram"],"mappings":"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","x_google_ignoreList":[0]}