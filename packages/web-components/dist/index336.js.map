{"version":3,"file":"index336.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/ticker/Ticker.mjs"],"sourcesContent":["import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 Âµs.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n"],"names":["_Ticker","TickerListener","time","fn","context","priority","UPDATE_PRIORITY","listener","current","previous","count","currentTime","elapsedMS","delta","head","fps","minFPS","minFPMS","maxFPS","shared","system","Ticker"],"mappings":"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","x_google_ignoreList":[0]}