{"version":3,"file":"index122.js","sources":["../../../node_modules/.pnpm/@pixi+text@7.4.3_@pixi+core@7.4.3_@pixi+sprite@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3__/node_modules/@pixi/text/lib/TextMetrics.mjs"],"sourcesContent":["import { settings } from \"@pixi/core\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: !0\n}, _TextMetrics = class _TextMetrics2 {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see PIXI.TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _TextMetrics2._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;\n      result = _TextMetrics2._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param wordWrap - Override for if word-wrap should be applied to the text.\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {\n    wordWrap = wordWrap ?? style.wordWrap;\n    const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);\n    fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);\n    const context = canvas.getContext(\"2d\", contextSettings);\n    context.font = font;\n    const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\\r\\n|\\r|\\n)/), lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _TextMetrics2._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n    style.dropShadow && (width += style.dropShadowDistance);\n    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);\n    return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = !1;\n    _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = \"0px\", context.textLetterSpacing = \"0px\"));\n    let width = context.measureText(text).width;\n    return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static wordWrap(text, style, canvas = _TextMetrics2._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0, line = \"\", lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_TextMetrics2.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _TextMetrics2.addLine(line), canPrependSpaces = !collapseSpaces, line = \"\", width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace)\n          continue;\n      }\n      const tokenWidth = _TextMetrics2.getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth)\n        if (line !== \"\" && (lines += _TextMetrics2.addLine(line), line = \"\", width = 0), _TextMetrics2.canBreakWords(token, style.breakWords)) {\n          const characters = _TextMetrics2.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j], lastChar = char, k = 1;\n            for (; characters[j + k]; ) {\n              const nextChar = characters[j + k];\n              if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                char += nextChar;\n              else\n                break;\n              lastChar = nextChar, k++;\n            }\n            j += k - 1;\n            const characterWidth = _TextMetrics2.getFromCache(char, letterSpacing, cache, context);\n            characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line), canPrependSpaces = !1, line = \"\", width = 0), line += char, width += characterWidth;\n          }\n        } else {\n          line.length > 0 && (lines += _TextMetrics2.addLine(line), line = \"\", width = 0);\n          const isLastToken = i === tokens.length - 1;\n          lines += _TextMetrics2.addLine(token, !isLastToken), canPrependSpaces = !1, line = \"\", width = 0;\n        }\n      else\n        tokenWidth + width > wordWrapWidth && (canPrependSpaces = !1, lines += _TextMetrics2.addLine(line), line = \"\", width = 0), (line.length > 0 || !_TextMetrics2.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth);\n    }\n    return lines += _TextMetrics2.addLine(line, !1), lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static addLine(line, newLine = !0) {\n    return line = _TextMetrics2.trimRight(line), line = newLine ? `${line}\n` : line, line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    return typeof width != \"number\" && (width = _TextMetrics2._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width), width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static trimRight(text) {\n    if (typeof text != \"string\")\n      return \"\";\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_TextMetrics2.isBreakingSpace(char))\n        break;\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static isNewline(char) {\n    return typeof char != \"string\" ? !1 : _TextMetrics2._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    return typeof char != \"string\" ? !1 : _TextMetrics2._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text != \"string\")\n      return tokens;\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i], nextChar = text[i + 1];\n      if (_TextMetrics2.isBreakingSpace(char, nextChar) || _TextMetrics2.isNewline(char)) {\n        token !== \"\" && (tokens.push(token), token = \"\"), tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    return token !== \"\" && tokens.push(token), tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return !0;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see TextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _TextMetrics2.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_TextMetrics2._fonts[font])\n      return _TextMetrics2._fonts[font];\n    const properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, canvas = _TextMetrics2._canvas, context = _TextMetrics2._context;\n    context.font = font;\n    const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(context.measureText(_TextMetrics2.BASELINE_SYMBOL).width);\n    const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);\n    if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)\n      return _TextMetrics2._fonts[font] = properties, properties;\n    canvas.width = width, canvas.height = height, context.fillStyle = \"#f00\", context.fillRect(0, 0, width, height), context.font = font, context.textBaseline = \"alphabetic\", context.fillStyle = \"#000\", context.fillText(metricsString, 0, baseline);\n    const imagedata = context.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = width * 4;\n    let i = 0, idx = 0, stop = !1;\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx += line;\n      else\n        break;\n    }\n    for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx -= line;\n      else\n        break;\n    }\n    return properties.descent = i - baseline, properties.fontSize = properties.ascent + properties.descent, _TextMetrics2._fonts[font] = properties, properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_TextMetrics2.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        if (c.getContext(\"2d\", contextSettings)?.measureText)\n          return _TextMetrics2.__canvas = c, c;\n        canvas = settings.ADAPTER.createCanvas();\n      } catch {\n        canvas = settings.ADAPTER.createCanvas();\n      }\n      canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;\n    }\n    return _TextMetrics2.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext(\"2d\", contextSettings)), _TextMetrics2.__context;\n  }\n};\n_TextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\", /** Baseline symbol for calculate font metrics. */\n_TextMetrics.BASELINE_SYMBOL = \"M\", /** Baseline multiplier for calculate font metrics. */\n_TextMetrics.BASELINE_MULTIPLIER = 1.4, /** Height multiplier for setting height of canvas to calculate font metrics. */\n_TextMetrics.HEIGHT_MULTIPLIER = 2, /**\n* A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n* such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n* or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n* The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n* PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n* If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n* you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n* or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n* relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n*/\n_TextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter == \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})(), /**\n* New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n* lead to more accurate letter-spacing results because it does not try to manually draw\n* each character. However, this Chrome API is experimental and may not serve all cases yet.\n* @see PIXI.TextMetrics.experimentalLetterSpacingSupported\n*/\n_TextMetrics.experimentalLetterSpacing = !1, /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */\n_TextMetrics._fonts = {}, /** Cache of new line chars. */\n_TextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n], /** Cache of breaking spaces. */\n_TextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\nlet TextMetrics = _TextMetrics;\nexport {\n  TextMetrics\n};\n//# sourceMappingURL=TextMetrics.mjs.map\n"],"names":["contextSettings","_TextMetrics","_TextMetrics2","result","proto","settings","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","wordWrap","canvas","font","context","i","lineWidth","letterSpacing","useExperimentalLetterSpacing","line","cache","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","token","currIsBreakingSpace","lastIsBreakingSpace","tokenWidth","characters","j","char","lastChar","k","nextChar","characterWidth","isLastToken","newLine","key","_nextChar","_token","breakWords","_char","_index","_breakWords","properties","metricsString","baseline","imagedata","pixels","idx","stop","c","_a","segmenter","s","x","TextMetrics"],"mappings":"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","x_google_ignoreList":[0]}