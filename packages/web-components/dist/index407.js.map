{"version":3,"file":"index407.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"],"sourcesContent":["import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const outerLeft = _x - strokeWidthOuter;\n    const outerRight = _x + width + strokeWidthOuter;\n    const outerTop = _y - strokeWidthOuter;\n    const outerBottom = _y + height + strokeWidthOuter;\n    const innerLeft = _x + strokeWidthInner;\n    const innerRight = _x + width - strokeWidthInner;\n    const innerTop = _y + strokeWidthInner;\n    const innerBottom = _y + height - strokeWidthInner;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.copyFrom(this);\n    return out;\n  }\n  /**\n   * Checks if this rectangle fully contains another rectangle.\n   *\n   * A rectangle contains another rectangle if all four corners of the other rectangle\n   * lie within the bounds of this rectangle.\n   *\n   * ```ts\n   * const container = new Rectangle(0, 0, 100, 100);\n   * const inside = new Rectangle(25, 25, 50, 50);\n   * const partial = new Rectangle(75, 75, 50, 50);\n   *\n   * container.containsRect(inside); // Returns true\n   * container.containsRect(partial); // Returns false - partial overlap\n   * ```\n   *\n   * Note: If either rectangle has a width or height of 0, this method returns false\n   * since a zero-area rectangle cannot meaningfully contain another rectangle.\n   * @param other - The rectangle to check if it is contained within this one\n   * @returns True if the other rectangle is fully contained within this one\n   */\n  containsRect(other) {\n    if (this.width <= 0 || this.height <= 0)\n      return false;\n    const x1 = other.x;\n    const y1 = other.y;\n    const x2 = other.x + other.width;\n    const y2 = other.y + other.height;\n    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n"],"names":["tempPoints","Point","Rectangle","x","y","width","height","bounds","rectangle","strokeWidth","alignment","_x","_y","strokeWidthOuter","strokeWidthInner","outerLeft","outerRight","outerTop","outerBottom","innerLeft","innerRight","innerTop","innerBottom","other","transform","x02","y02","x0","x1","y0","y1","lt","lb","rt","rb","s","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","paddingX","paddingY","x2","y2","resolution","eps","out"],"mappings":"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","x_google_ignoreList":[0]}