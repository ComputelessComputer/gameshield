{"version":3,"file":"index363.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/utils/path.mjs"],"sourcesContent":["import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n"],"names":["assertPath","path2","removeUrlParams","url","escapeRegExp","string","replaceAll","str","find","replace","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","code","i","lastSlashIndex","path","matchFile","matchProtocol","customBaseUrl","customRootUrl","baseUrl","DOMAdapter","rootUrl","protocol","isAbsolute","trailingSeparator","segments","joined","arg","prevArg","hasRoot","end","matchedSlash","proto","origpath","root","index","ext","start","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret"],"mappings":";AAGA,SAASA,EAAWC,GAAO;AACzB,MAAI,OAAOA,KAAU;AACnB,UAAM,IAAI,UAAU,mCAAmC,KAAK,UAAUA,CAAK,CAAC,EAAE;AAElF;AACA,SAASC,EAAgBC,GAAK;AAE5B,SADWA,EAAI,MAAM,GAAG,EAAE,CAAC,EACjB,MAAM,GAAG,EAAE,CAAC;AACxB;AACA,SAASC,EAAaC,GAAQ;AAC5B,SAAOA,EAAO,QAAQ,uBAAuB,MAAM;AACrD;AACA,SAASC,EAAWC,GAAKC,GAAMC,GAAS;AACtC,SAAOF,EAAI,QAAQ,IAAI,OAAOH,EAAaI,CAAI,GAAG,GAAG,GAAGC,CAAO;AACjE;AACA,SAASC,EAAqBT,GAAOU,GAAgB;AACnD,MAAIC,IAAM,IACNC,IAAoB,GACpBC,IAAY,IACZC,IAAO,GACPC,IAAO;AACX,WAASC,IAAI,GAAGA,KAAKhB,EAAM,QAAQ,EAAEgB,GAAG;AACtC,QAAIA,IAAIhB,EAAM;AACZ,MAAAe,IAAOf,EAAM,WAAWgB,CAAC;AAAA,SACpB;AAAA,UAAID,MAAS;AAClB;AAEA,MAAAA,IAAO;AAAA;AAET,QAAIA,MAAS,IAAI;AACf,UAAI,EAAAF,MAAcG,IAAI,KAAKF,MAAS;AAC7B,YAAID,MAAcG,IAAI,KAAKF,MAAS,GAAG;AAC5C,cAAIH,EAAI,SAAS,KAAKC,MAAsB,KAAKD,EAAI,WAAWA,EAAI,SAAS,CAAC,MAAM,MAAMA,EAAI,WAAWA,EAAI,SAAS,CAAC,MAAM;AAC3H,gBAAIA,EAAI,SAAS,GAAG;AAClB,oBAAMM,IAAiBN,EAAI,YAAY,GAAG;AAC1C,kBAAIM,MAAmBN,EAAI,SAAS,GAAG;AACrC,gBAAIM,MAAmB,MACrBN,IAAM,IACNC,IAAoB,MAEpBD,IAAMA,EAAI,MAAM,GAAGM,CAAc,GACjCL,IAAoBD,EAAI,SAAS,IAAIA,EAAI,YAAY,GAAG,IAE1DE,IAAYG,GACZF,IAAO;AACP;AAAA,cACD;AAAA,YACb,WAAqBH,EAAI,WAAW,KAAKA,EAAI,WAAW,GAAG;AAC/C,cAAAA,IAAM,IACNC,IAAoB,GACpBC,IAAYG,GACZF,IAAO;AACP;AAAA,YACD;AAAA;AAEH,UAAIJ,MACEC,EAAI,SAAS,IACfA,KAAO,QAEPA,IAAM,MAERC,IAAoB;AAAA,QAE9B;AACQ,UAAID,EAAI,SAAS,IACfA,KAAO,IAAIX,EAAM,MAAMa,IAAY,GAAGG,CAAC,CAAC,KAExCL,IAAMX,EAAM,MAAMa,IAAY,GAAGG,CAAC,GAEpCJ,IAAoBI,IAAIH,IAAY;AAEtC,MAAAA,IAAYG,GACZF,IAAO;AAAA,IACR;AAAM,MAAIC,MAAS,MAAMD,MAAS,KACjC,EAAEA,IAEFA,IAAO;AAAA,EAEV;AACD,SAAOH;AACT;AACK,MAACO,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKX,QAAQlB,GAAO;AACb,WAAOK,EAAWL,GAAO,MAAM,GAAG;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,MAAMA,GAAO;AACX,WAAO,WAAW,KAAK,KAAK,QAAQA,CAAK,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,UAAUA,GAAO;AACf,WAAO,yIAAyI,KAAKA,CAAK;AAAA,EAC3J;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,UAAUA,GAAO;AACf,WAAOA,EAAM,WAAW,OAAO;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,YAAYA,GAAO;AACjB,WAAO,WAAW,KAAK,KAAK,QAAQA,CAAK,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,YAAYA,GAAO;AACjB,IAAAD,EAAWC,CAAK,GAChBA,IAAQ,KAAK,QAAQA,CAAK;AAC1B,UAAMmB,IAAY,eAAe,KAAKnB,CAAK;AAC3C,QAAImB;AACF,aAAOA,EAAU,CAAC;AAEpB,UAAMC,IAAgB,kBAAkB,KAAKpB,CAAK;AAClD,WAAIoB,IACKA,EAAc,CAAC,IAEjB;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,WAAWlB,GAAKmB,GAAeC,GAAe;AAE5C,QADAvB,EAAWG,CAAG,GACV,KAAK,UAAUA,CAAG,KAAK,KAAK,UAAUA,CAAG;AAC3C,aAAOA;AACT,UAAMqB,IAAUtB,EAAgB,KAAK,QAAQoB,KAAiBG,EAAW,IAAK,EAAC,WAAY,CAAA,CAAC,GACtFC,IAAUxB,EAAgB,KAAK,QAAQqB,KAAiB,KAAK,SAASC,CAAO,CAAC,CAAC;AAErF,WADArB,IAAM,KAAK,QAAQA,CAAG,GAClBA,EAAI,WAAW,GAAG,IACbgB,EAAK,KAAKO,GAASvB,EAAI,MAAM,CAAC,CAAC,IAEnB,KAAK,WAAWA,CAAG,IAAIA,IAAM,KAAK,KAAKqB,GAASrB,CAAG;AAAA,EAEzE;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,UAAUF,GAAO;AAEf,QADAD,EAAWC,CAAK,GACZA,EAAM,WAAW;AACnB,aAAO;AACT,QAAI,KAAK,UAAUA,CAAK,KAAK,KAAK,UAAUA,CAAK;AAC/C,aAAOA;AACT,IAAAA,IAAQ,KAAK,QAAQA,CAAK;AAC1B,QAAI0B,IAAW;AACf,UAAMC,IAAa3B,EAAM,WAAW,GAAG;AACvC,IAAI,KAAK,YAAYA,CAAK,MACxB0B,IAAW,KAAK,SAAS1B,CAAK,GAC9BA,IAAQA,EAAM,MAAM0B,EAAS,MAAM;AAErC,UAAME,IAAoB5B,EAAM,SAAS,GAAG;AAI5C,WAHAA,IAAQS,EAAqBT,GAAO,EAAK,GACrCA,EAAM,SAAS,KAAK4B,MACtB5B,KAAS,MACP2B,IACK,IAAI3B,CAAK,KACX0B,IAAW1B;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,WAAWA,GAAO;AAGhB,WAFAD,EAAWC,CAAK,GAChBA,IAAQ,KAAK,QAAQA,CAAK,GACtB,KAAK,YAAYA,CAAK,IACjB,KACFA,EAAM,WAAW,GAAG;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,QAAQ6B,GAAU;AAChB,QAAIA,EAAS,WAAW;AACtB,aAAO;AAET,QAAIC;AACJ,aAAS,IAAI,GAAG,IAAID,EAAS,QAAQ,EAAE,GAAG;AACxC,YAAME,IAAMF,EAAS,CAAC;AAEtB,UADA9B,EAAWgC,CAAG,GACVA,EAAI,SAAS;AACf,YAAID,MAAW;AACb,UAAAA,IAASC;AAAA,aACN;AACH,gBAAMC,IAAUH,EAAS,IAAI,CAAC,KAAK;AACnC,UAAI,KAAK,eAAe,SAAS,KAAK,QAAQG,CAAO,EAAE,YAAW,CAAE,IAClEF,KAAU,OAAOC,CAAG,KAEpBD,KAAU,IAAIC,CAAG;AAAA,QAEpB;AAAA,IAEJ;AACD,WAAID,MAAW,SACN,MAEF,KAAK,UAAUA,CAAM;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,QAAQ9B,GAAO;AAEb,QADAD,EAAWC,CAAK,GACZA,EAAM,WAAW;AACnB,aAAO;AACT,IAAAA,IAAQ,KAAK,QAAQA,CAAK;AAC1B,QAAIe,IAAOf,EAAM,WAAW,CAAC;AAC7B,UAAMiC,IAAUlB,MAAS;AACzB,QAAImB,IAAM,IACNC,IAAe;AACnB,UAAMC,IAAQ,KAAK,YAAYpC,CAAK,GAC9BqC,IAAWrC;AACjB,IAAAA,IAAQA,EAAM,MAAMoC,EAAM,MAAM;AAChC,aAASpB,IAAIhB,EAAM,SAAS,GAAGgB,KAAK,GAAG,EAAEA;AAEvC,UADAD,IAAOf,EAAM,WAAWgB,CAAC,GACrBD,MAAS;AACX,YAAI,CAACoB,GAAc;AACjB,UAAAD,IAAMlB;AACN;AAAA,QACD;AAAA;AAED,QAAAmB,IAAe;AAGnB,WAAID,MAAQ,KACHD,IAAU,MAAM,KAAK,MAAMI,CAAQ,IAAID,IAAQpC,IAAQoC,IAC5DH,KAAWC,MAAQ,IACd,OACFE,IAAQpC,EAAM,MAAM,GAAGkC,CAAG;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,SAASlC,GAAO;AACd,IAAAD,EAAWC,CAAK,GAChBA,IAAQ,KAAK,QAAQA,CAAK;AAC1B,QAAIsC,IAAO;AAMX,QALItC,EAAM,WAAW,GAAG,IACtBsC,IAAO,MAEPA,IAAO,KAAK,YAAYtC,CAAK,GAE3B,KAAK,MAAMA,CAAK,GAAG;AACrB,YAAMuC,IAAQvC,EAAM,QAAQ,KAAKsC,EAAK,MAAM;AAC5C,MAAIC,MAAU,KACZD,IAAOtC,EAAM,MAAM,GAAGuC,CAAK,IAE3BD,IAAOtC,GACJsC,EAAK,SAAS,GAAG,MACpBA,KAAQ;AAAA,IACX;AACD,WAAOA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,SAAStC,GAAOwC,GAAK;AACnB,IAAAzC,EAAWC,CAAK,GACZwC,KACFzC,EAAWyC,CAAG,GAChBxC,IAAQC,EAAgB,KAAK,QAAQD,CAAK,CAAC;AAC3C,QAAIyC,IAAQ,GACRP,IAAM,IACNC,IAAe,IACfnB;AACJ,QAAIwB,MAAQ,UAAUA,EAAI,SAAS,KAAKA,EAAI,UAAUxC,EAAM,QAAQ;AAClE,UAAIwC,EAAI,WAAWxC,EAAM,UAAUwC,MAAQxC;AACzC,eAAO;AACT,UAAI0C,IAASF,EAAI,SAAS,GACtBG,IAAmB;AACvB,WAAK3B,IAAIhB,EAAM,SAAS,GAAGgB,KAAK,GAAG,EAAEA,GAAG;AACtC,cAAMD,IAAOf,EAAM,WAAWgB,CAAC;AAC/B,YAAID,MAAS;AACX,cAAI,CAACoB,GAAc;AACjB,YAAAM,IAAQzB,IAAI;AACZ;AAAA,UACD;AAAA;AAED,UAAI2B,MAAqB,OACvBR,IAAe,IACfQ,IAAmB3B,IAAI,IAErB0B,KAAU,MACR3B,MAASyB,EAAI,WAAWE,CAAM,IAC5B,EAAEA,MAAW,OACfR,IAAMlB,MAGR0B,IAAS,IACTR,IAAMS;AAAA,MAIb;AACD,aAAIF,MAAUP,IACZA,IAAMS,IACCT,MAAQ,OACfA,IAAMlC,EAAM,SACPA,EAAM,MAAMyC,GAAOP,CAAG;AAAA,IAC9B;AACD,SAAKlB,IAAIhB,EAAM,SAAS,GAAGgB,KAAK,GAAG,EAAEA;AACnC,UAAIhB,EAAM,WAAWgB,CAAC,MAAM;AAC1B,YAAI,CAACmB,GAAc;AACjB,UAAAM,IAAQzB,IAAI;AACZ;AAAA,QACD;AAAA;AACI,QAAIkB,MAAQ,OACjBC,IAAe,IACfD,IAAMlB,IAAI;AAGd,WAAIkB,MAAQ,KACH,KACFlC,EAAM,MAAMyC,GAAOP,CAAG;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,QAAQlC,GAAO;AACb,IAAAD,EAAWC,CAAK,GAChBA,IAAQC,EAAgB,KAAK,QAAQD,CAAK,CAAC;AAC3C,QAAI4C,IAAW,IACXC,IAAY,GACZX,IAAM,IACNC,IAAe,IACfW,IAAc;AAClB,aAAS9B,IAAIhB,EAAM,SAAS,GAAGgB,KAAK,GAAG,EAAEA,GAAG;AAC1C,YAAMD,IAAOf,EAAM,WAAWgB,CAAC;AAC/B,UAAID,MAAS,IAAI;AACf,YAAI,CAACoB,GAAc;AACjB,UAAAU,IAAY7B,IAAI;AAChB;AAAA,QACD;AACD;AAAA,MACD;AACD,MAAIkB,MAAQ,OACVC,IAAe,IACfD,IAAMlB,IAAI,IAERD,MAAS,KACP6B,MAAa,KACfA,IAAW5B,IACJ8B,MAAgB,MACvBA,IAAc,KACPF,MAAa,OACtBE,IAAc;AAAA,IAEjB;AACD,WAAIF,MAAa,MAAMV,MAAQ,MAAMY,MAAgB,KAAKA,MAAgB,KAAKF,MAAaV,IAAM,KAAKU,MAAaC,IAAY,IACvH,KAEF7C,EAAM,MAAM4C,GAAUV,CAAG;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,MAAMlC,GAAO;AACX,IAAAD,EAAWC,CAAK;AAChB,UAAM+C,IAAM,EAAE,MAAM,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,MAAM,GAAE;AAC5D,QAAI/C,EAAM,WAAW;AACnB,aAAO+C;AACT,IAAA/C,IAAQC,EAAgB,KAAK,QAAQD,CAAK,CAAC;AAC3C,QAAIe,IAAOf,EAAM,WAAW,CAAC;AAC7B,UAAM2B,IAAa,KAAK,WAAW3B,CAAK;AACxC,QAAIyC;AAEJ,IAAAM,EAAI,OAAO,KAAK,SAAS/C,CAAK,GAC1B2B,KAAc,KAAK,YAAY3B,CAAK,IACtCyC,IAAQ,IAERA,IAAQ;AAEV,QAAIG,IAAW,IACXC,IAAY,GACZX,IAAM,IACNC,IAAe,IACfnB,IAAIhB,EAAM,SAAS,GACnB8C,IAAc;AAClB,WAAO9B,KAAKyB,GAAO,EAAEzB,GAAG;AAEtB,UADAD,IAAOf,EAAM,WAAWgB,CAAC,GACrBD,MAAS,IAAI;AACf,YAAI,CAACoB,GAAc;AACjB,UAAAU,IAAY7B,IAAI;AAChB;AAAA,QACD;AACD;AAAA,MACD;AACD,MAAIkB,MAAQ,OACVC,IAAe,IACfD,IAAMlB,IAAI,IAERD,MAAS,KACP6B,MAAa,KACfA,IAAW5B,IACJ8B,MAAgB,MACvBA,IAAc,KACPF,MAAa,OACtBE,IAAc;AAAA,IAEjB;AACD,WAAIF,MAAa,MAAMV,MAAQ,MAAMY,MAAgB,KAAKA,MAAgB,KAAKF,MAAaV,IAAM,KAAKU,MAAaC,IAAY,IAC1HX,MAAQ,OACNW,MAAc,KAAKlB,IACrBoB,EAAI,OAAOA,EAAI,OAAO/C,EAAM,MAAM,GAAGkC,CAAG,IAExCa,EAAI,OAAOA,EAAI,OAAO/C,EAAM,MAAM6C,GAAWX,CAAG,MAGhDW,MAAc,KAAKlB,KACrBoB,EAAI,OAAO/C,EAAM,MAAM,GAAG4C,CAAQ,GAClCG,EAAI,OAAO/C,EAAM,MAAM,GAAGkC,CAAG,MAE7Ba,EAAI,OAAO/C,EAAM,MAAM6C,GAAWD,CAAQ,GAC1CG,EAAI,OAAO/C,EAAM,MAAM6C,GAAWX,CAAG,IAEvCa,EAAI,MAAM/C,EAAM,MAAM4C,GAAUV,CAAG,IAErCa,EAAI,MAAM,KAAK,QAAQ/C,CAAK,GAGrB+C;AAAA,EACR;AAAA,EACD,KAAK;AAAA,EACL,WAAW;AAAA,EACX,gBAAgB,CAAC,OAAO;AAC1B;","x_google_ignoreList":[0]}