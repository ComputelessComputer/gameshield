{"version":3,"file":"index108.js","sources":["../../../node_modules/.pnpm/@pixi+graphics@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3__@pixi+sprit_3c40fa602f454a6b22dad0b27bc41147/node_modules/@pixi/graphics/lib/Graphics.mjs"],"sourcesContent":["import { State, Color, BLEND_MODES, Texture, Polygon, PI_2, Rectangle, RoundedRectangle, Circle, Ellipse, SHAPES, Matrix, UniformGroup, Shader, Point } from \"@pixi/core\";\nimport { Container } from \"@pixi/display\";\nimport { LINE_CAP, LINE_JOIN, curves } from \"./const.mjs\";\nimport { GraphicsGeometry } from \"./GraphicsGeometry.mjs\";\nimport { FillStyle } from \"./styles/FillStyle.mjs\";\nimport { LineStyle } from \"./styles/LineStyle.mjs\";\nimport \"./utils/index.mjs\";\nimport { QuadraticUtils } from \"./utils/QuadraticUtils.mjs\";\nimport { BezierUtils } from \"./utils/BezierUtils.mjs\";\nimport { ArcUtils } from \"./utils/ArcUtils.mjs\";\nconst DEFAULT_SHADERS = {}, _Graphics = class _Graphics2 extends Container {\n  /**\n   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n   */\n  constructor(geometry = null) {\n    super(), this.shader = null, this.pluginName = \"batch\", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new FillStyle(), this._lineStyle = new LineStyle(), this._matrix = null, this._holeMode = !1, this.state = State.for2d(), this._geometry = geometry || new GraphicsGeometry(), this._geometry.refCount++, this._transformID = -1, this._tintColor = new Color(16777215), this.blendMode = BLEND_MODES.NORMAL;\n  }\n  /**\n   * Includes vertex positions, face indices, normals, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n   * @readonly\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   * @returns - A clone of the graphics object\n   */\n  clone() {\n    return this.finishPoly(), new _Graphics2(this._geometry);\n  }\n  /**\n   * The blend mode to be applied to the graphic shape. Apply a value of\n   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n   * primitive in the GraphicsGeometry list is rendered sequentially, modes\n   * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n   * be applied per-primitive.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  /**\n   * The tint applied to each graphic shape. This is a hex value. A value of\n   * 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n  }\n  /**\n   * The current fill style.\n   * @readonly\n   */\n  get fill() {\n    return this._fillStyle;\n  }\n  /**\n   * The current line style.\n   * @readonly\n   */\n  get line() {\n    return this._lineStyle;\n  }\n  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = !1) {\n    return typeof options == \"number\" && (options = { width: options, color, alpha, alignment, native }), this.lineTextureStyle(options);\n  }\n  /**\n   * Like line style but support texture for line fill.\n   * @param [options] - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   *        WebGL only.\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  lineTextureStyle(options) {\n    const defaultLineStyleOptions = {\n      width: 0,\n      texture: Texture.WHITE,\n      color: options?.texture ? 16777215 : 0,\n      matrix: null,\n      alignment: 0.5,\n      native: !1,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    };\n    options = Object.assign(defaultLineStyleOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();\n    const visible = options.width > 0 && options.alpha > 0;\n    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, { visible }, options)) : this._lineStyle.reset(), this;\n  }\n  /**\n   * Start a polygon object internally.\n   * @protected\n   */\n  startPoly() {\n    if (this.currentPath) {\n      const points = this.currentPath.points, len = this.currentPath.points.length;\n      len > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(points[len - 2], points[len - 1]));\n    } else\n      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n  }\n  /**\n   * Finish the polygon object.\n   * @protected\n   */\n  finishPoly() {\n    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n  }\n  /**\n   * Moves the current drawing position to x, y.\n   * @param x - the X coordinate to move to\n   * @param y - the Y coordinate to move to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  moveTo(x, y) {\n    return this.startPoly(), this.currentPath.points[0] = x, this.currentPath.points[1] = y, this;\n  }\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   * @param x - the X coordinate to draw to\n   * @param y - the Y coordinate to draw to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  lineTo(x, y) {\n    this.currentPath || this.moveTo(0, 0);\n    const points = this.currentPath.points, fromX = points[points.length - 2], fromY = points[points.length - 1];\n    return (fromX !== x || fromY !== y) && points.push(x, y), this;\n  }\n  /**\n   * Initialize the curve\n   * @param x\n   * @param y\n   */\n  _initCurve(x = 0, y = 0) {\n    this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x, y]) : this.moveTo(x, y);\n  }\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._initCurve();\n    const points = this.currentPath.points;\n    return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;\n  }\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns This Graphics object. Good for chaining method calls\n   */\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    return this._initCurve(), BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;\n  }\n  /**\n   * The `arcTo` method creates an arc/curve between two tangents on the canvas.\n   * The first tangent is from the start point to the first control point,\n   * and the second tangent is from the first control point to the second control point.\n   * Note that the second control point is not necessarily the end point of the arc.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   * @param x1 - The x-coordinate of the first control point of the arc\n   * @param y1 - The y-coordinate of the first control point of the arc\n   * @param x2 - The x-coordinate of the second control point of the arc\n   * @param y2 - The y-coordinate of the second control point of the arc\n   * @param radius - The radius of the arc\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    const points = this.currentPath.points, result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;\n      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  }\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = !1) {\n    if (startAngle === endAngle)\n      return this;\n    if (!anticlockwise && endAngle <= startAngle ? endAngle += PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += PI_2), endAngle - startAngle === 0)\n      return this;\n    const startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;\n    let points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      const xDiff = Math.abs(points[points.length - 2] - startX), yDiff = Math.abs(points[points.length - 1] - startY);\n      xDiff < eps && yDiff < eps || points.push(startX, startY);\n    } else\n      this.moveTo(startX, startY), points = this.currentPath.points;\n    return ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this;\n  }\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   * @param {PIXI.ColorSource} color - the color of the fill\n   * @param alpha - the alpha of the fill, will override the color's alpha\n   * @returns - This Graphics object. Suitable for chaining method calls\n   */\n  beginFill(color = 0, alpha) {\n    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n  }\n  /**\n   * Normalize the color input from options for line style or fill\n   * @param {PIXI.IFillStyleOptions} options - Fill style object.\n   */\n  normalizeColor(options) {\n    const temp = Color.shared.setValue(options.color ?? 0);\n    options.color = temp.toNumber(), options.alpha ?? (options.alpha = temp.alpha);\n  }\n  /**\n   * Begin the texture fill.\n   * Note: The wrap mode of the texture is forced to REPEAT on render.\n   * @param options - Fill style object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha] - Alpha of fill, overrides the color's alpha\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  beginTextureFill(options) {\n    const defaultOptions = {\n      texture: Texture.WHITE,\n      color: 16777215,\n      matrix: null\n    };\n    options = Object.assign(defaultOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();\n    const visible = options.alpha > 0;\n    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, { visible }, options)) : this._fillStyle.reset(), this;\n  }\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  endFill() {\n    return this.finishPoly(), this._fillStyle.reset(), this;\n  }\n  /**\n   * Draws a rectangle shape.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawRect(x, y, width, height) {\n    return this.drawShape(new Rectangle(x, y, width, height));\n  }\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @param radius - Radius of the rectangle corners\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawRoundedRect(x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  }\n  /**\n   * Draws a circle.\n   * @param x - The X coordinate of the center of the circle\n   * @param y - The Y coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawCircle(x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  }\n  /**\n   * Draws an ellipse.\n   * @param x - The X coordinate of the center of the ellipse\n   * @param y - The Y coordinate of the center of the ellipse\n   * @param width - The half width of the ellipse\n   * @param height - The half height of the ellipse\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawEllipse(x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  }\n  /**\n   * Draws a polygon using the given path.\n   * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawPolygon(...path) {\n    let points, closeStroke = !0;\n    const poly = path[0];\n    poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path[0]) ? points = path[0] : points = path;\n    const shape = new Polygon(points);\n    return shape.closeStroke = closeStroke, this.drawShape(shape), this;\n  }\n  /**\n   * Draw any shape.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawShape(shape) {\n    return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(\n      shape,\n      this._fillStyle.clone(),\n      this._lineStyle.clone(),\n      this._matrix\n    ), this;\n  }\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  clear() {\n    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n  }\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   * @returns - True if only 1 rect.\n   */\n  isFastRect() {\n    const data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  _render(renderer) {\n    this.finishPoly();\n    const geometry = this._geometry;\n    geometry.updateBatches(), geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));\n  }\n  /** Populating batches for rendering. */\n  _populateBatches() {\n    const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;\n    this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.batches.length = len, this.vertexData = new Float32Array(geometry.points);\n    for (let i = 0; i < len; i++) {\n      const gI = geometry.batches[i], color = gI.style.color, vertexData = new Float32Array(\n        this.vertexData.buffer,\n        gI.attribStart * 4 * 2,\n        gI.attribSize * 2\n      ), uvs = new Float32Array(\n        geometry.uvsFloat32.buffer,\n        gI.attribStart * 4 * 2,\n        gI.attribSize * 2\n      ), indices = new Uint16Array(\n        geometry.indicesUint16.buffer,\n        gI.start * 2,\n        gI.size\n      ), batch = {\n        vertexData,\n        blendMode,\n        indices,\n        uvs,\n        _batchRGB: Color.shared.setValue(color).toRgbArray(),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  }\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   * @param renderer - The renderer\n   */\n  _renderBatched(renderer) {\n    if (this.batches.length) {\n      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n      for (let i = 0, l = this.batches.length; i < l; i++) {\n        const batch = this.batches[i];\n        batch.worldAlpha = this.worldAlpha * batch.alpha, renderer.plugins[this.pluginName].render(batch);\n      }\n    }\n  }\n  /**\n   * Renders the graphics direct\n   * @param renderer - The renderer\n   */\n  _renderDirect(renderer) {\n    const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;\n    uniforms.translationMatrix = this.transform.worldTransform, Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint), renderer.shader.bind(shader), renderer.geometry.bind(geometry, shader), renderer.state.set(this.state);\n    for (let i = 0, l = drawCalls.length; i < l; i++)\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n  }\n  /**\n   * Renders specific DrawCall\n   * @param renderer\n   * @param drawCall\n   */\n  _renderDrawCallDirect(renderer, drawCall) {\n    const { texArray, type, size, start } = drawCall, groupTextureCount = texArray.count;\n    for (let j = 0; j < groupTextureCount; j++)\n      renderer.texture.bind(texArray.elements[j], j);\n    renderer.geometry.draw(type, size, start);\n  }\n  /**\n   * Resolves shader for direct rendering\n   * @param renderer - The renderer\n   */\n  _resolveDirectShader(renderer) {\n    let shader = this.shader;\n    const pluginName = this.pluginName;\n    if (!shader) {\n      if (!DEFAULT_SHADERS[pluginName]) {\n        const { maxTextures } = renderer.plugins[pluginName], sampleValues = new Int32Array(maxTextures);\n        for (let i = 0; i < maxTextures; i++)\n          sampleValues[i] = i;\n        const uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: sampleValues }, !0)\n        }, program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  }\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object.\n   * @see PIXI.GraphicsGeometry#bounds\n   */\n  _calculateBounds() {\n    this.finishPoly();\n    const geometry = this._geometry;\n    if (!geometry.graphicsData.length)\n      return;\n    const { minX, minY, maxX, maxY } = geometry.bounds;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  /**\n   * Tests if a point is inside this graphics object\n   * @param point - the point to test\n   * @returns - the result of the test\n   */\n  containsPoint(point) {\n    return this.worldTransform.applyInverse(point, _Graphics2._TEMP_POINT), this._geometry.containsPoint(_Graphics2._TEMP_POINT);\n  }\n  /** Recalculate the tint by applying tint to batches using Graphics tint. */\n  calculateTints() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this._tintColor.toNumber();\n      for (let i = 0; i < this.batches.length; i++) {\n        const batch = this.batches[i];\n        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();\n      }\n    }\n  }\n  /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\n  calculateVertices() {\n    const wtID = this.transform._worldID;\n    if (this._transformID === wtID)\n      return;\n    this._transformID = wtID;\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, data = this._geometry.points, vertexData = this.vertexData;\n    let count = 0;\n    for (let i = 0; i < data.length; i += 2) {\n      const x = data[i], y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx, vertexData[count++] = d * y + b * x + ty;\n    }\n  }\n  /**\n   * Closes the current path.\n   * @returns - Returns itself.\n   */\n  closePath() {\n    const currentPath = this.currentPath;\n    return currentPath && (currentPath.closeStroke = !0, this.finishPoly()), this;\n  }\n  /**\n   * Apply a matrix to the positional data.\n   * @param matrix - Matrix to use for transform current shape.\n   * @returns - Returns itself.\n   */\n  setMatrix(matrix) {\n    return this._matrix = matrix, this;\n  }\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   * @returns - Returns itself.\n   */\n  beginHole() {\n    return this.finishPoly(), this._holeMode = !0, this;\n  }\n  /**\n   * End adding holes to the last draw shape.\n   * @returns - Returns itself.\n   */\n  endHole() {\n    return this.finishPoly(), this._holeMode = !1, this;\n  }\n  /**\n   * Destroys the Graphics object.\n   * @param options - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  destroy(options) {\n    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(options);\n  }\n};\n_Graphics.curves = curves, /**\n* Temporary point to use for containsPoint.\n* @private\n*/\n_Graphics._TEMP_POINT = new Point();\nlet Graphics = _Graphics;\nexport {\n  Graphics\n};\n//# sourceMappingURL=Graphics.mjs.map\n"],"names":["DEFAULT_SHADERS","_Graphics","_Graphics2","Container","geometry","FillStyle","LineStyle","State","GraphicsGeometry","Color","BLEND_MODES","value","options","color","alpha","alignment","native","defaultLineStyleOptions","Texture","LINE_CAP","LINE_JOIN","visible","points","len","Polygon","x","y","fromX","fromY","cpX","cpY","toX","toY","QuadraticUtils","cpX2","cpY2","BezierUtils","x1","y1","x2","y2","radius","result","ArcUtils","cx","cy","radius2","startAngle","endAngle","anticlockwise","PI_2","startX","startY","eps","xDiff","yDiff","temp","defaultOptions","width","height","Rectangle","RoundedRectangle","Circle","Ellipse","path","closeStroke","poly","shape","data","SHAPES","renderer","blendMode","gI","vertexData","uvs","indices","batch","i","l","shader","worldAlpha","uniforms","drawCalls","drawCall","texArray","type","size","start","groupTextureCount","j","pluginName","maxTextures","sampleValues","Matrix","UniformGroup","program","Shader","minX","minY","maxX","maxY","point","wtID","wt","a","b","c","d","tx","ty","count","currentPath","matrix","curves","Point","Graphics"],"mappings":"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","x_google_ignoreList":[0]}