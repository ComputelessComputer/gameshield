{"version":3,"file":"index108.js","sources":["../../../node_modules/.pnpm/@pixi+extract@7.4.3_@pixi+core@7.4.3/node_modules/@pixi/extract/lib/Extract.mjs"],"sourcesContent":["import { Rectangle, utils, RenderTexture, FORMATS, ExtensionType, extensions } from \"@pixi/core\";\nconst TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, _Extract = class _Extract2 {\n  /**\n   * @param renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this._rendererPremultipliedAlpha = !1;\n  }\n  contextChange() {\n    const attributes = this.renderer?.gl.getContextAttributes();\n    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - HTML Image of the target\n   */\n  async image(target, format, quality, frame) {\n    const image = new Image();\n    return image.src = await this.base64(target, format, quality, frame), image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   *  `Extract.canvas` and then running toDataURL on that.\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - A base64 encoded string of the texture.\n   */\n  async base64(target, format, quality, frame) {\n    const canvas = this.canvas(target, frame);\n    if (canvas.toBlob !== void 0)\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);\n        }, format, quality);\n      });\n    if (canvas.toDataURL !== void 0)\n      return canvas.toDataURL(format, quality);\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: format, quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(target, frame) {\n    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);\n    flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels);\n    const canvasBuffer = new utils.CanvasRenderTarget(width, height, 1), imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n    return canvasBuffer.context.putImageData(imageData, 0, 0), canvasBuffer.canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(target, frame) {\n    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);\n    return flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels), pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    if (!renderer)\n      throw new Error(\"The Extract has already been destroyed\");\n    let resolution, flipY = !1, premultipliedAlpha = !1, renderTexture, generated = !1;\n    target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {\n      region: frame,\n      resolution: renderer.resolution,\n      multisample: renderer.multisample\n    }), generated = !0, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));\n    const gl = renderer.gl;\n    if (renderTexture) {\n      if (resolution = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = !1, premultipliedAlpha = renderTexture.baseTexture.alphaMode > 0 && renderTexture.baseTexture.format === FORMATS.RGBA, !generated) {\n        renderer.renderTexture.bind(renderTexture);\n        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n        fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);\n      }\n    } else\n      resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution), flipY = !0, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();\n    const width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    return gl.readPixels(\n      Math.round(frame.x * resolution),\n      Math.round(frame.y * resolution),\n      width,\n      height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    ), generated && renderTexture?.destroy(!0), { pixels, width, height, flipY, premultipliedAlpha };\n  }\n  /** Destroys the extract. */\n  destroy() {\n    this.renderer = null;\n  }\n  static _flipY(pixels, width, height) {\n    const w = width << 2, h = height >> 1, temp = new Uint8Array(w);\n    for (let y = 0; y < h; y++) {\n      const t = y * w, b = (height - y - 1) * w;\n      temp.set(pixels.subarray(t, t + w)), pixels.copyWithin(t, b, b + w), pixels.set(temp, b);\n    }\n  }\n  static _unpremultiplyAlpha(pixels) {\n    pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));\n    const n = pixels.length;\n    for (let i = 0; i < n; i += 4) {\n      const alpha = pixels[i + 3];\n      if (alpha !== 0) {\n        const a = 255.001 / alpha;\n        pixels[i] = pixels[i] * a + 0.5, pixels[i + 1] = pixels[i + 1] * a + 0.5, pixels[i + 2] = pixels[i + 2] * a + 0.5;\n      }\n    }\n  }\n};\n_Extract.extension = {\n  name: \"extract\",\n  type: ExtensionType.RendererSystem\n};\nlet Extract = _Extract;\nextensions.add(Extract);\nexport {\n  Extract\n};\n//# sourceMappingURL=Extract.mjs.map\n"],"names":["TEMP_RECT","Rectangle","BYTES_PER_PIXEL","_Extract","_Extract2","renderer","attributes","_a","target","format","quality","frame","image","canvas","resolve","reject","blob","reader","pixels","width","height","flipY","premultipliedAlpha","canvasBuffer","utils.CanvasRenderTarget","imageData","resolution","renderTexture","generated","RenderTexture","gl","FORMATS","fbo","w","h","temp","y","t","b","n","i","alpha","a","ExtensionType","Extract","extensions"],"mappings":"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","x_google_ignoreList":[0]}