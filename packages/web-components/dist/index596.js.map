{"version":3,"file":"index596.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"],"sourcesContent":["import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n"],"names":["_Spritesheet","texture","data","Texture","metaResolution","resolve","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","orig","Rectangle","animations","animName","frameName","callback","destroyBase","_a","Spritesheet"],"mappings":"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","x_google_ignoreList":[0]}