{"version":3,"file":"index121.js","sources":["../../../node_modules/.pnpm/@pixi+text@7.4.3_@pixi+core@7.4.3_@pixi+sprite@7.4.3_@pixi+core@7.4.3_@pixi+display@7.4.3_@pixi+core@7.4.3__/node_modules/@pixi/text/lib/Text.mjs"],"sourcesContent":["import { settings, Texture, Rectangle, utils, Color } from \"@pixi/core\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { TEXT_GRADIENT } from \"./const.mjs\";\nimport { TextMetrics } from \"./TextMetrics.mjs\";\nimport { TextStyle } from \"./TextStyle.mjs\";\nconst defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, _Text = class _Text2 extends Sprite {\n  /**\n   * @param text - The string that you would like the text to display\n   * @param style - The style parameters\n   * @param canvas - The canvas element for drawing text\n   */\n  constructor(text, style, canvas) {\n    let ownCanvas = !1;\n    canvas || (canvas = settings.ADAPTER.createCanvas(), ownCanvas = !0), canvas.width = 3, canvas.height = 3;\n    const texture = Texture.from(canvas);\n    texture.orig = new Rectangle(), texture.trim = new Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext(\"2d\", {\n      // required for trimming to work without warnings\n      willReadFrequently: !0\n    }), this._resolution = _Text2.defaultResolution ?? settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = \"\", this.text = text, this.style = style, this.localStyleID = -1;\n  }\n  /**\n   * @see PIXI.TextMetrics.experimentalLetterSpacing\n   * @deprecated since 7.1.0\n   */\n  static get experimentalLetterSpacing() {\n    return TextMetrics.experimentalLetterSpacing;\n  }\n  static set experimentalLetterSpacing(value) {\n    utils.deprecation(\n      \"7.1.0\",\n      \"Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing\"\n    ), TextMetrics.experimentalLetterSpacing = value;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n   */\n  updateText(respectDirty) {\n    const style = this._style;\n    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty)\n      return;\n    this._font = this._style.toFontString();\n    const context = this.context, measured = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), width = measured.width, height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context.scale(this._resolution, this._resolution), context.clearRect(0, 0, this.canvas.width, this.canvas.height), context.font = this._font, context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit;\n    let linePositionX, linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0, dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0, dsOffsetShadow = dsOffsetText * this._resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\", context.strokeStyle = \"black\";\n        const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * this._resolution, dropShadowDistance = style.dropShadowDistance * this._resolution;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n      } else\n        context.fillStyle = this._generateFillStyle(style, lines, measured), context.strokeStyle = style.stroke, context.shadowColor = \"black\", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);\n      for (let i2 = 0; i2 < lines.length; i2++)\n        linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === \"right\" ? linePositionX += maxLineWidth - lineWidths[i2] : style.align === \"center\" && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(\n          lines[i2],\n          linePositionX + style.padding,\n          linePositionY + style.padding - dsOffsetText,\n          !0\n        ), style.fill && this.drawLetterSpacing(\n          lines[i2],\n          linePositionX + style.padding,\n          linePositionY + style.padding - dsOffsetText\n        );\n    }\n    this.updateTexture();\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  drawLetterSpacing(text, x, y, isStroke = !1) {\n    const letterSpacing = this._style.letterSpacing;\n    let useExperimentalLetterSpacing = !1;\n    if (TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (this.context.letterSpacing = \"0px\", this.context.textLetterSpacing = \"0px\")), letterSpacing === 0 || useExperimentalLetterSpacing) {\n      isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y);\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = TextMetrics.graphemeSegmenter(text);\n    let previousWidth = this.context.measureText(text).width, currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      isStroke ? this.context.strokeText(currentChar, currentPosition, y) : this.context.fillText(currentChar, currentPosition, y);\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j)\n        textStr += stringArray[j];\n      currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;\n    }\n  }\n  /** Updates texture size based on canvas size. */\n  updateTexture() {\n    const canvas = this.canvas;\n    if (this._style.trim) {\n      const trimmed = utils.trimCanvas(canvas);\n      trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));\n    }\n    const texture = this._texture, style = this._style, padding = style.trim ? 0 : style.padding, baseTexture = texture.baseTexture;\n    texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = !1;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  _render(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);\n  }\n  /** Updates the transform on all children of this container for rendering. */\n  updateTransform() {\n    this.updateText(!0), super.updateTransform();\n  }\n  getBounds(skipUpdate, rect) {\n    return this.updateText(!0), this._textureID === -1 && (skipUpdate = !1), super.getBounds(skipUpdate, rect);\n  }\n  /**\n   * Gets the local bounds of the text object.\n   * @param rect - The output rectangle.\n   * @returns The bounds.\n   */\n  getLocalBounds(rect) {\n    return this.updateText(!0), super.getLocalBounds.call(this, rect);\n  }\n  /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n  _calculateBounds() {\n    this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }\n  /**\n   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n   * @param style - The style.\n   * @param lines - The lines of text.\n   * @param metrics\n   * @returns The fill style\n   */\n  _generateFillStyle(style, lines, metrics) {\n    const fillStyle = style.fill;\n    if (Array.isArray(fillStyle)) {\n      if (fillStyle.length === 1)\n        return fillStyle[0];\n    } else\n      return fillStyle;\n    let gradient;\n    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2, height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();\n    if (!fillGradientStops.length) {\n      const lengthPlus1 = fill.length + 1;\n      for (let i = 1; i < lengthPlus1; ++i)\n        fillGradientStops.push(i / lengthPlus1);\n    }\n    if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n      for (let i = 0; i < lines.length; i++) {\n        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight, thisLineTop = metrics.lineHeight * i;\n        let thisLineGradientStart = thisLineTop;\n        i > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);\n        const thisLineBottom = thisLineTop + textHeight, nextLineTop = metrics.lineHeight * (i + 1);\n        let thisLineGradientEnd = thisLineBottom;\n        i + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);\n        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n        for (let j = 0; j < fill.length; j++) {\n          let lineStop = 0;\n          typeof fillGradientStops[j] == \"number\" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;\n          let globalStop = Math.min(1, Math.max(\n            0,\n            thisLineGradientStart / height + lineStop * gradStopLineHeight\n          ));\n          globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j]);\n        }\n      }\n    } else {\n      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n      const totalIterations = fill.length + 1;\n      let currentIteration = 1;\n      for (let i = 0; i < fill.length; i++) {\n        let stop;\n        typeof fillGradientStops[i] == \"number\" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;\n      }\n    }\n    return gradient;\n  }\n  /**\n   * Destroys this text object.\n   *\n   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n   * the majority of the time the texture will not be shared with any other Sprites.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n   */\n  destroy(options) {\n    typeof options == \"boolean\" && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n  }\n  /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this.updateText(!0);\n    const s = utils.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width, this._width = value;\n  }\n  /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this.updateText(!0);\n    const s = utils.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height, this._height = value;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link PIXI.ITextStyle}.\n   */\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    style = style || {}, style instanceof TextStyle ? this._style = style : this._style = new TextStyle(style), this.localStyleID = -1, this.dirty = !0;\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text ?? \"\"), this._text !== text && (this._text = text, this.dirty = !0);\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   *\n   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n   * @default 1\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n  }\n};\n_Text.defaultAutoResolution = !0;\nlet Text = _Text;\nexport {\n  Text\n};\n//# sourceMappingURL=Text.mjs.map\n"],"names":["defaultDestroyOptions","_Text","_Text2","Sprite","text","style","canvas","ownCanvas","settings","texture","Texture","Rectangle","TextMetrics","value","utils.deprecation","respectDirty","context","measured","width","height","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","linePositionX","linePositionY","passesCount","i","isShadowPass","dsOffsetText","dsOffsetShadow","dropShadowColor","dropShadowBlur","dropShadowDistance","Color","linePositionYShift","i2","x","y","isStroke","letterSpacing","useExperimentalLetterSpacing","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","j","trimmed","utils.trimCanvas","padding","baseTexture","renderer","skipUpdate","rect","metrics","fillStyle","gradient","dropShadowCorrection","fill","fillGradientStops","lengthPlus1","TEXT_GRADIENT","textHeight","lastLineBottom","thisLineTop","thisLineGradientStart","thisLineBottom","nextLineTop","thisLineGradientEnd","gradStopLineHeight","lineStop","globalStop","totalIterations","currentIteration","stop","options","s","utils.sign","TextStyle","Text"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAMA,IAAwB;AAAA,EAC5B,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AACf,GAAGC,IAAQ,MAAMC,UAAeC,EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMrC,YAAYC,GAAMC,GAAOC,GAAQ;AAC/B,QAAIC,IAAY;AAChB,IAAAD,MAAWA,IAASE,EAAS,QAAQ,aAAY,GAAID,IAAY,KAAKD,EAAO,QAAQ,GAAGA,EAAO,SAAS;AACxG,UAAMG,IAAUC,EAAQ,KAAKJ,CAAM;AACnC,IAAAG,EAAQ,OAAO,IAAIE,KAAaF,EAAQ,OAAO,IAAIE,EAAS,GAAI,MAAMF,CAAO,GAAG,KAAK,aAAaF,GAAW,KAAK,SAASD,GAAQ,KAAK,UAAUA,EAAO,WAAW,MAAM;AAAA;AAAA,MAExK,oBAAoB;AAAA,IAC1B,CAAK,GAAG,KAAK,cAAcJ,EAAO,qBAAqBM,EAAS,YAAY,KAAK,kBAAkBN,EAAO,uBAAuB,KAAK,QAAQ,MAAM,KAAK,SAAS,MAAM,KAAK,iBAAiB,MAAM,KAAK,QAAQ,IAAI,KAAK,OAAOE,GAAM,KAAK,QAAQC,GAAO,KAAK,eAAe;AAAA,EAC5Q;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,WAAW,4BAA4B;AACrC,WAAOO,EAAY;AAAA,EACpB;AAAA,EACD,WAAW,0BAA0BC,GAAO;AAC1CC,IAAAA;AAAAA,MACE;AAAA,MACA;AAAA,IACN,GAAOF,EAAY,4BAA4BC;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,WAAWE,GAAc;AACvB,UAAMV,IAAQ,KAAK;AACnB,QAAI,KAAK,iBAAiBA,EAAM,YAAY,KAAK,QAAQ,IAAI,KAAK,eAAeA,EAAM,UAAU,CAAC,KAAK,SAASU;AAC9G;AACF,SAAK,QAAQ,KAAK,OAAO,aAAY;AACrC,UAAMC,IAAU,KAAK,SAASC,IAAWL,EAAY,YAAY,KAAK,SAAS,KAAK,KAAK,QAAQ,KAAK,OAAO,UAAU,KAAK,MAAM,GAAGM,IAAQD,EAAS,OAAOE,IAASF,EAAS,QAAQG,IAAQH,EAAS,OAAOI,IAAaJ,EAAS,YAAYK,IAAaL,EAAS,YAAYM,IAAeN,EAAS,cAAcO,IAAiBP,EAAS;AACnV,SAAK,OAAO,QAAQ,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI,GAAGC,CAAK,IAAIb,EAAM,UAAU,CAAC,IAAI,KAAK,WAAW,GAAG,KAAK,OAAO,SAAS,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI,GAAGc,CAAM,IAAId,EAAM,UAAU,CAAC,IAAI,KAAK,WAAW,GAAGW,EAAQ,MAAM,KAAK,aAAa,KAAK,WAAW,GAAGA,EAAQ,UAAU,GAAG,GAAG,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM,GAAGA,EAAQ,OAAO,KAAK,OAAOA,EAAQ,YAAYX,EAAM,iBAAiBW,EAAQ,eAAeX,EAAM,cAAcW,EAAQ,WAAWX,EAAM,UAAUW,EAAQ,aAAaX,EAAM;AAC9e,QAAIoB,GAAeC;AACnB,UAAMC,IAActB,EAAM,aAAa,IAAI;AAC3C,aAASuB,IAAI,GAAGA,IAAID,GAAa,EAAEC,GAAG;AACpC,YAAMC,IAAexB,EAAM,cAAcuB,MAAM,GAAGE,IAAeD,IAAe,KAAK,KAAK,KAAK,IAAI,GAAGV,CAAM,IAAId,EAAM,UAAU,CAAC,IAAI,GAAG0B,IAAiBD,IAAe,KAAK;AAC7K,UAAID,GAAc;AAChB,QAAAb,EAAQ,YAAY,SAASA,EAAQ,cAAc;AACnD,cAAMgB,IAAkB3B,EAAM,iBAAiB4B,IAAiB5B,EAAM,iBAAiB,KAAK,aAAa6B,IAAqB7B,EAAM,qBAAqB,KAAK;AAC9J,QAAAW,EAAQ,cAAcmB,EAAM,OAAO,SAASH,CAAe,EAAE,SAAS3B,EAAM,eAAe,EAAE,aAAY,GAAIW,EAAQ,aAAaiB,GAAgBjB,EAAQ,gBAAgB,KAAK,IAAIX,EAAM,eAAe,IAAI6B,GAAoBlB,EAAQ,gBAAgB,KAAK,IAAIX,EAAM,eAAe,IAAI6B,IAAqBH;AAAA,MAChT;AACC,QAAAf,EAAQ,YAAY,KAAK,mBAAmBX,GAAOe,GAAOH,CAAQ,GAAGD,EAAQ,cAAcX,EAAM,QAAQW,EAAQ,cAAc,SAASA,EAAQ,aAAa,GAAGA,EAAQ,gBAAgB,GAAGA,EAAQ,gBAAgB;AACrN,UAAIoB,KAAsBf,IAAaG,EAAe,YAAY;AAClE,MAAAH,IAAaG,EAAe,WAAW,MAAMY,IAAqB;AAClE,eAASC,IAAK,GAAGA,IAAKjB,EAAM,QAAQiB;AAClC,QAAAZ,IAAgBpB,EAAM,kBAAkB,GAAGqB,IAAgBrB,EAAM,kBAAkB,IAAIgC,IAAKhB,IAAaG,EAAe,SAASY,GAAoB/B,EAAM,UAAU,UAAUoB,KAAiBF,IAAeD,EAAWe,CAAE,IAAIhC,EAAM,UAAU,aAAaoB,MAAkBF,IAAeD,EAAWe,CAAE,KAAK,IAAIhC,EAAM,UAAUA,EAAM,mBAAmB,KAAK;AAAA,UAChWe,EAAMiB,CAAE;AAAA,UACRZ,IAAgBpB,EAAM;AAAA,UACtBqB,IAAgBrB,EAAM,UAAUyB;AAAA,UAChC;AAAA,QACV,GAAWzB,EAAM,QAAQ,KAAK;AAAA,UACpBe,EAAMiB,CAAE;AAAA,UACRZ,IAAgBpB,EAAM;AAAA,UACtBqB,IAAgBrB,EAAM,UAAUyB;AAAA,QAC1C;AAAA,IACK;AACD,SAAK,cAAa;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,kBAAkB1B,GAAMkC,GAAGC,GAAGC,IAAW,IAAI;AAC3C,UAAMC,IAAgB,KAAK,OAAO;AAClC,QAAIC,IAA+B;AACnC,QAAI9B,EAAY,uCAAuCA,EAAY,6BAA6B,KAAK,QAAQ,gBAAgB,GAAG6B,CAAa,MAAM,KAAK,QAAQ,oBAAoB,GAAGA,CAAa,MAAMC,IAA+B,OAAO,KAAK,QAAQ,gBAAgB,OAAO,KAAK,QAAQ,oBAAoB,SAASD,MAAkB,KAAKC,GAA8B;AACjX,MAAAF,IAAW,KAAK,QAAQ,WAAWpC,GAAMkC,GAAGC,CAAC,IAAI,KAAK,QAAQ,SAASnC,GAAMkC,GAAGC,CAAC;AACjF;AAAA,IACD;AACD,QAAII,IAAkBL;AACtB,UAAMM,IAAchC,EAAY,kBAAkBR,CAAI;AACtD,QAAIyC,IAAgB,KAAK,QAAQ,YAAYzC,CAAI,EAAE,OAAO0C,IAAe;AACzE,aAASlB,IAAI,GAAGA,IAAIgB,EAAY,QAAQ,EAAEhB,GAAG;AAC3C,YAAMmB,IAAcH,EAAYhB,CAAC;AACjC,MAAAY,IAAW,KAAK,QAAQ,WAAWO,GAAaJ,GAAiBJ,CAAC,IAAI,KAAK,QAAQ,SAASQ,GAAaJ,GAAiBJ,CAAC;AAC3H,UAAIS,IAAU;AACd,eAASC,IAAIrB,IAAI,GAAGqB,IAAIL,EAAY,QAAQ,EAAEK;AAC5C,QAAAD,KAAWJ,EAAYK,CAAC;AAC1B,MAAAH,IAAe,KAAK,QAAQ,YAAYE,CAAO,EAAE,OAAOL,KAAmBE,IAAgBC,IAAeL,GAAeI,IAAgBC;AAAA,IAC1I;AAAA,EACF;AAAA;AAAA,EAED,gBAAgB;AACd,UAAMxC,IAAS,KAAK;AACpB,QAAI,KAAK,OAAO,MAAM;AACpB,YAAM4C,IAAUC,EAAiB7C,CAAM;AACvC,MAAA4C,EAAQ,SAAS5C,EAAO,QAAQ4C,EAAQ,OAAO5C,EAAO,SAAS4C,EAAQ,QAAQ,KAAK,QAAQ,aAAaA,EAAQ,MAAM,GAAG,CAAC;AAAA,IAC5H;AACD,UAAMzC,IAAU,KAAK,UAAUJ,IAAQ,KAAK,QAAQ+C,IAAU/C,EAAM,OAAO,IAAIA,EAAM,SAASgD,IAAc5C,EAAQ;AACpH,IAAAA,EAAQ,KAAK,QAAQA,EAAQ,OAAO,QAAQH,EAAO,QAAQ,KAAK,aAAaG,EAAQ,KAAK,SAASA,EAAQ,OAAO,SAASH,EAAO,SAAS,KAAK,aAAaG,EAAQ,KAAK,IAAI,CAAC2C,GAAS3C,EAAQ,KAAK,IAAI,CAAC2C,GAAS3C,EAAQ,KAAK,QAAQA,EAAQ,OAAO,QAAQ2C,IAAU,GAAG3C,EAAQ,KAAK,SAASA,EAAQ,OAAO,SAAS2C,IAAU,GAAG,KAAK,iBAAkB,GAAEC,EAAY,YAAY/C,EAAO,OAAOA,EAAO,QAAQ,KAAK,WAAW,GAAGG,EAAQ,UAAW,GAAE,KAAK,QAAQ;AAAA,EAC3c;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,QAAQ6C,GAAU;AAChB,SAAK,mBAAmB,KAAK,gBAAgBA,EAAS,eAAe,KAAK,cAAcA,EAAS,YAAY,KAAK,QAAQ,KAAK,KAAK,WAAW,EAAE,GAAG,MAAM,QAAQA,CAAQ;AAAA,EAC3K;AAAA;AAAA,EAED,kBAAkB;AAChB,SAAK,WAAW,EAAE,GAAG,MAAM,gBAAe;AAAA,EAC3C;AAAA,EACD,UAAUC,GAAYC,GAAM;AAC1B,WAAO,KAAK,WAAW,EAAE,GAAG,KAAK,eAAe,OAAOD,IAAa,KAAK,MAAM,UAAUA,GAAYC,CAAI;AAAA,EAC1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,eAAeA,GAAM;AACnB,WAAO,KAAK,WAAW,EAAE,GAAG,MAAM,eAAe,KAAK,MAAMA,CAAI;AAAA,EACjE;AAAA;AAAA,EAED,mBAAmB;AACjB,SAAK,kBAAiB,GAAI,KAAK,QAAQ,QAAQ,KAAK,UAAU;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,mBAAmBnD,GAAOe,GAAOqC,GAAS;AACxC,UAAMC,IAAYrD,EAAM;AACxB,QAAI,MAAM,QAAQqD,CAAS;AACzB,UAAIA,EAAU,WAAW;AACvB,eAAOA,EAAU,CAAC;AAAA;AAEpB,aAAOA;AACT,QAAIC;AACJ,UAAMC,IAAuBvD,EAAM,aAAaA,EAAM,qBAAqB,GAAG+C,IAAU/C,EAAM,WAAW,GAAGa,IAAQ,KAAK,OAAO,QAAQ,KAAK,cAAc0C,IAAuBR,IAAU,GAAGjC,IAAS,KAAK,OAAO,SAAS,KAAK,cAAcyC,IAAuBR,IAAU,GAAGS,IAAOH,EAAU,MAAO,GAAEI,IAAoBzD,EAAM,kBAAkB;AAC1V,QAAI,CAACyD,EAAkB,QAAQ;AAC7B,YAAMC,IAAcF,EAAK,SAAS;AAClC,eAASjC,IAAI,GAAGA,IAAImC,GAAa,EAAEnC;AACjC,QAAAkC,EAAkB,KAAKlC,IAAImC,CAAW;AAAA,IACzC;AACD,QAAIF,EAAK,QAAQH,EAAU,CAAC,CAAC,GAAGI,EAAkB,QAAQ,CAAC,GAAGD,EAAK,KAAKH,EAAUA,EAAU,SAAS,CAAC,CAAC,GAAGI,EAAkB,KAAK,CAAC,GAAGzD,EAAM,qBAAqB2D,EAAc,iBAAiB;AAC7L,MAAAL,IAAW,KAAK,QAAQ,qBAAqBzC,IAAQ,GAAGkC,GAASlC,IAAQ,GAAGC,IAASiC,CAAO;AAC5F,YAAMa,IAAaR,EAAQ,eAAe,WAAWpD,EAAM;AAC3D,eAASuB,IAAI,GAAGA,IAAIR,EAAM,QAAQQ,KAAK;AACrC,cAAMsC,IAAiBT,EAAQ,cAAc7B,IAAI,KAAKqC,GAAYE,IAAcV,EAAQ,aAAa7B;AACrG,YAAIwC,IAAwBD;AAC5B,QAAAvC,IAAI,KAAKsC,IAAiBC,MAAgBC,KAAyBD,IAAcD,KAAkB;AACnG,cAAMG,IAAiBF,IAAcF,GAAYK,IAAcb,EAAQ,cAAc7B,IAAI;AACzF,YAAI2C,IAAsBF;AAC1B,QAAAzC,IAAI,IAAIR,EAAM,UAAUkD,IAAcD,MAAmBE,KAAuBF,IAAiBC,KAAe;AAChH,cAAME,KAAsBD,IAAsBH,KAAyBjD;AAC3E,iBAAS8B,IAAI,GAAGA,IAAIY,EAAK,QAAQZ,KAAK;AACpC,cAAIwB,IAAW;AACf,iBAAOX,EAAkBb,CAAC,KAAK,WAAWwB,IAAWX,EAAkBb,CAAC,IAAIwB,IAAWxB,IAAIY,EAAK;AAChG,cAAIa,IAAa,KAAK,IAAI,GAAG,KAAK;AAAA,YAChC;AAAA,YACAN,IAAwBjD,IAASsD,IAAWD;AAAA,UACxD,CAAW;AACD,UAAAE,IAAa,OAAOA,EAAW,QAAQ,CAAC,CAAC,GAAGf,EAAS,aAAae,GAAYb,EAAKZ,CAAC,CAAC;AAAA,QACtF;AAAA,MACF;AAAA,IACP,OAAW;AACL,MAAAU,IAAW,KAAK,QAAQ,qBAAqBP,GAASjC,IAAS,GAAGD,IAAQkC,GAASjC,IAAS,CAAC;AAC7F,YAAMwD,IAAkBd,EAAK,SAAS;AACtC,UAAIe,IAAmB;AACvB,eAAShD,IAAI,GAAGA,IAAIiC,EAAK,QAAQjC,KAAK;AACpC,YAAIiD;AACJ,eAAOf,EAAkBlC,CAAC,KAAK,WAAWiD,IAAOf,EAAkBlC,CAAC,IAAIiD,IAAOD,IAAmBD,GAAiBhB,EAAS,aAAakB,GAAMhB,EAAKjC,CAAC,CAAC,GAAGgD;AAAA,MAC1J;AAAA,IACF;AACD,WAAOjB;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaD,QAAQmB,GAAS;AACf,WAAOA,KAAW,cAAcA,IAAU,EAAE,UAAUA,EAAS,IAAGA,IAAU,OAAO,OAAO,CAAE,GAAE9E,GAAuB8E,CAAO,GAAG,MAAM,QAAQA,CAAO,GAAG,KAAK,eAAe,KAAK,OAAO,SAAS,KAAK,OAAO,QAAQ,IAAI,KAAK,UAAU,MAAM,KAAK,SAAS,MAAM,KAAK,SAAS;AAAA,EAChR;AAAA;AAAA,EAED,IAAI,QAAQ;AACV,WAAO,KAAK,WAAW,EAAE,GAAG,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;AAAA,EACzE;AAAA,EACD,IAAI,MAAMjE,GAAO;AACf,SAAK,WAAW,EAAE;AAClB,UAAMkE,IAAIC,EAAW,KAAK,MAAM,CAAC,KAAK;AACtC,SAAK,MAAM,IAAID,IAAIlE,IAAQ,KAAK,SAAS,KAAK,OAAO,KAAK,SAASA;AAAA,EACpE;AAAA;AAAA,EAED,IAAI,SAAS;AACX,WAAO,KAAK,WAAW,EAAE,GAAG,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;AAAA,EACzE;AAAA,EACD,IAAI,OAAOA,GAAO;AAChB,SAAK,WAAW,EAAE;AAClB,UAAMkE,IAAIC,EAAW,KAAK,MAAM,CAAC,KAAK;AACtC,SAAK,MAAM,IAAID,IAAIlE,IAAQ,KAAK,SAAS,KAAK,QAAQ,KAAK,UAAUA;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,MAAMR,GAAO;AACf,IAAAA,IAAQA,KAAS,CAAA,GAAIA,aAAiB4E,IAAY,KAAK,SAAS5E,IAAQ,KAAK,SAAS,IAAI4E,EAAU5E,CAAK,GAAG,KAAK,eAAe,IAAI,KAAK,QAAQ;AAAA,EAClJ;AAAA;AAAA,EAED,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,KAAKD,GAAM;AACb,IAAAA,IAAO,OAAOA,KAAQ,EAAE,GAAG,KAAK,UAAUA,MAAS,KAAK,QAAQA,GAAM,KAAK,QAAQ;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,IAAI,aAAa;AACf,WAAO,KAAK;AAAA,EACb;AAAA,EACD,IAAI,WAAWS,GAAO;AACpB,SAAK,kBAAkB,IAAI,KAAK,gBAAgBA,MAAU,KAAK,cAAcA,GAAO,KAAK,QAAQ;AAAA,EAClG;AACH;AACAZ,EAAM,wBAAwB;AAC3B,IAACiF,KAAOjF;","x_google_ignoreList":[0]}