{"version":3,"file":"index409.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"],"sourcesContent":["import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nlet tempRect;\nlet tempRect2;\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Determines whether the polygon's points are arranged in a clockwise direction.\n   * This is calculated using the \"shoelace formula\" (also known as surveyor's formula) to find the signed area.\n   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n   *\n   * The formula sums up the cross products of adjacent vertices:\n   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n   * The final sum divided by 2 gives the signed area - positive for clockwise.\n   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n   */\n  isClockwise() {\n    let area = 0;\n    const points = this.points;\n    const length = points.length;\n    for (let i = 0; i < length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % length];\n      const y2 = points[(i + 3) % length];\n      area += (x2 - x1) * (y2 + y1);\n    }\n    return area < 0;\n  }\n  /**\n   * Checks if this polygon completely contains another polygon.\n   *\n   * This is useful for detecting holes in shapes, like when parsing SVG paths.\n   * For example, if you have two polygons:\n   * ```ts\n   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n   *\n   * outerSquare.containsPolygon(innerSquare); // Returns true\n   * innerSquare.containsPolygon(outerSquare); // Returns false\n   * ```\n   * @param polygon - The polygon to test for containment\n   * @returns True if this polygon completely contains the other polygon\n   */\n  containsPolygon(polygon) {\n    const thisBounds = this.getBounds(tempRect);\n    const otherBounds = polygon.getBounds(tempRect2);\n    if (!thisBounds.containsRect(otherBounds)) {\n      return false;\n    }\n    const points = polygon.points;\n    for (let i = 0; i < points.length; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      if (!this.contains(x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const strokeWidthSquared = strokeWidth * strokeWidth;\n    const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n"],"names":["tempRect","tempRect2","Polygon","points","flat","p","i","il","area","length","x1","y1","x2","y2","polygon","thisBounds","otherBounds","x","y","inside","j","xi","yi","xj","yj","strokeWidth","alignment","strokeWidthSquared","rightWidthSquared","leftWidthSquared","iterationLength","distanceSquared","squaredDistanceToLineSegment","sign","out","Rectangle","minX","maxX","minY","maxY","n","pointsDesc","currentPoint"],"mappings":";;AAIA,IAAIA,GACAC;AACJ,MAAMC,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQZ,eAAeC,GAAQ;AAKrB,SAAK,OAAO;AACZ,QAAIC,IAAO,MAAM,QAAQD,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAIA;AAClD,QAAI,OAAOC,EAAK,CAAC,KAAM,UAAU;AAC/B,YAAMC,IAAI,CAAA;AACV,eAASC,IAAI,GAAGC,IAAKH,EAAK,QAAQE,IAAIC,GAAID;AACxC,QAAAD,EAAE,KAAKD,EAAKE,CAAC,EAAE,GAAGF,EAAKE,CAAC,EAAE,CAAC;AAE7B,MAAAF,IAAOC;AAAA,IACR;AACD,SAAK,SAASD,GACd,KAAK,YAAY;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWD,cAAc;AACZ,QAAII,IAAO;AACX,UAAML,IAAS,KAAK,QACdM,IAASN,EAAO;AACtB,aAASG,IAAI,GAAGA,IAAIG,GAAQH,KAAK,GAAG;AAClC,YAAMI,IAAKP,EAAOG,CAAC,GACbK,IAAKR,EAAOG,IAAI,CAAC,GACjBM,IAAKT,GAAQG,IAAI,KAAKG,CAAM,GAC5BI,IAAKV,GAAQG,IAAI,KAAKG,CAAM;AAClC,MAAAD,MAASI,IAAKF,MAAOG,IAAKF;AAAA,IAC3B;AACD,WAAOH,IAAO;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBD,gBAAgBM,GAAS;AACvB,UAAMC,IAAa,KAAK,UAAUf,CAAQ,GACpCgB,IAAcF,EAAQ,UAAUb,CAAS;AAC/C,QAAI,CAACc,EAAW,aAAaC,CAAW;AACtC,aAAO;AAET,UAAMb,IAASW,EAAQ;AACvB,aAAS,IAAI,GAAG,IAAIX,EAAO,QAAQ,KAAK,GAAG;AACzC,YAAMc,IAAId,EAAO,CAAC,GACZe,IAAIf,EAAO,IAAI,CAAC;AACtB,UAAI,CAAC,KAAK,SAASc,GAAGC,CAAC;AACrB,eAAO;AAAA,IAEV;AACD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,QAAQ;AACN,UAAMf,IAAS,KAAK,OAAO,MAAK,GAC1BW,IAAU,IAAIZ,EAAQC,CAAM;AAClC,WAAAW,EAAQ,YAAY,KAAK,WAClBA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,SAASG,GAAGC,GAAG;AACb,QAAIC,IAAS;AACb,UAAMV,IAAS,KAAK,OAAO,SAAS;AACpC,aAAS,IAAI,GAAGW,IAAIX,IAAS,GAAG,IAAIA,GAAQW,IAAI,KAAK;AACnD,YAAMC,IAAK,KAAK,OAAO,IAAI,CAAC,GACtBC,IAAK,KAAK,OAAO,IAAI,IAAI,CAAC,GAC1BC,IAAK,KAAK,OAAOH,IAAI,CAAC,GACtBI,IAAK,KAAK,OAAOJ,IAAI,IAAI,CAAC;AAEhC,MADkBE,IAAKJ,KAAMM,IAAKN,KAAKD,KAAKM,IAAKF,OAAQH,IAAII,MAAOE,IAAKF,MAAOD,MAE9EF,IAAS,CAACA;AAAA,IAEb;AACD,WAAOA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,eAAeF,GAAGC,GAAGO,GAAaC,IAAY,KAAK;AACjD,UAAMC,IAAqBF,IAAcA,GACnCG,IAAoBD,KAAsB,IAAID,IAC9CG,IAAmBF,IAAqBC,GACxC,EAAE,QAAAzB,EAAQ,IAAG,MACb2B,IAAkB3B,EAAO,UAAU,KAAK,YAAY,IAAI;AAC9D,aAASG,IAAI,GAAGA,IAAIwB,GAAiBxB,KAAK,GAAG;AAC3C,YAAMI,IAAKP,EAAOG,CAAC,GACbK,IAAKR,EAAOG,IAAI,CAAC,GACjBM,IAAKT,GAAQG,IAAI,KAAKH,EAAO,MAAM,GACnCU,IAAKV,GAAQG,IAAI,KAAKH,EAAO,MAAM,GACnC4B,IAAkBC,EAA6Bf,GAAGC,GAAGR,GAAIC,GAAIC,GAAIC,CAAE,GACnEoB,IAAO,KAAK,MAAMrB,IAAKF,MAAOQ,IAAIP,MAAOE,IAAKF,MAAOM,IAAIP,EAAG;AAClE,UAAIqB,MAAoBE,IAAO,IAAIJ,IAAmBD;AACpD,eAAO;AAAA,IAEV;AACD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,UAAUM,GAAK;AACb,IAAAA,MAAQA,IAAM,IAAIC,EAAS;AAC3B,UAAMhC,IAAS,KAAK;AACpB,QAAIiC,IAAO,OACPC,IAAO,QACPC,IAAO,OACPC,IAAO;AACX,aAASjC,IAAI,GAAGkC,IAAIrC,EAAO,QAAQG,IAAIkC,GAAGlC,KAAK,GAAG;AAChD,YAAMW,IAAId,EAAOG,CAAC,GACZY,IAAIf,EAAOG,IAAI,CAAC;AACtB,MAAA8B,IAAOnB,IAAImB,IAAOnB,IAAImB,GACtBC,IAAOpB,IAAIoB,IAAOpB,IAAIoB,GACtBC,IAAOpB,IAAIoB,IAAOpB,IAAIoB,GACtBC,IAAOrB,IAAIqB,IAAOrB,IAAIqB;AAAA,IACvB;AACD,WAAAL,EAAI,IAAIE,GACRF,EAAI,QAAQG,IAAOD,GACnBF,EAAI,IAAII,GACRJ,EAAI,SAASK,IAAOD,GACbJ;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,SAASpB,GAAS;AAChB,gBAAK,SAASA,EAAQ,OAAO,MAAK,GAClC,KAAK,YAAYA,EAAQ,WAClB;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,OAAOA,GAAS;AACd,WAAAA,EAAQ,SAAS,IAAI,GACdA;AAAA,EACR;AAAA,EACD,WAAW;AACT,WAAO,oCAAoC,KAAK,SAAS,UAAU,KAAK,OAAO,OAAO,CAAC2B,GAAYC,MAAiB,GAAGD,CAAU,KAAKC,CAAY,IAAI,EAAE,CAAC;AAAA,EAC1J;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,QAAQ;AACV,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,QAAQ;AACV,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,IAAI;AACN,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,IAAI;AACN,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,EAC1C;AACH;","x_google_ignoreList":[0]}