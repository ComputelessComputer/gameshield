{"version":3,"file":"index348.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/assets/loader/Loader.mjs"],"sourcesContent":["import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item,\n      data: {}\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\nexport { Loader };\n//# sourceMappingURL=Loader.mjs.map\n"],"names":["Loader","target","key","value","url","data","result","asset","parser","warn","parserX","_a","parser2","_b","assetsToLoadIn","onProgress","count","assets","singleAsset","isSingleItem","assetsToLoad","convertToList","item","total","promises","path","e","assetsToUnloadIn","loadPromise","loadedAsset","hash"],"mappings":"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","x_google_ignoreList":[0]}