{"version":3,"file":"index146.js","sources":["../../../node_modules/.pnpm/@pixi+assets@7.4.3_@pixi+core@7.4.3/node_modules/@pixi/assets/lib/loader/Loader.mjs"],"sourcesContent":["import { utils } from \"@pixi/core\";\nimport \"../utils/index.mjs\";\nimport { isSingleItem } from \"../utils/isSingleItem.mjs\";\nimport { convertToList } from \"../utils/convertToList.mjs\";\nclass Loader {\n  constructor() {\n    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => (this._parsersValidated = !1, target[key] = value, !0)\n    }), this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = !1, this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    return result.promise = (async () => {\n      let asset = null, parser = null;\n      if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`)), !parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser)\n          return console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;\n      }\n      asset = await parser.load(url, data, this), result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        parser2.parse && parser2.parse && await parser2.testParse?.(asset, data, this) && (asset = await parser2.parse(asset, data, this) || asset, result.parser = parser2);\n      }\n      return asset;\n    })(), result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    this._parsersValidated || this._validateParsers();\n    let count = 0;\n    const assets = {}, singleAsset = isSingleItem(assetsToLoadIn), assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item\n    })), total = assetsToLoad.length, promises = assetsToLoad.map(async (asset) => {\n      const url = utils.path.toAbsolute(asset.src);\n      if (!assets[asset.src])\n        try {\n          this.promiseCache[url] || (this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset)), assets[asset.src] = await this.promiseCache[url].promise, onProgress && onProgress(++count / total);\n        } catch (e) {\n          throw delete this.promiseCache[url], delete assets[asset.src], new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n    });\n    return await Promise.all(promises), singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const promises = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    })).map(async (asset) => {\n      const url = utils.path.toAbsolute(asset.src), loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url], loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = !0, this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => (hash[parser.name] && console.warn(`[Assets] loadParser name conflict \"${parser.name}\"`), { ...hash, [parser.name]: parser }), {});\n  }\n}\nexport {\n  Loader\n};\n//# sourceMappingURL=Loader.mjs.map\n"],"names":["Loader","target","key","value","url","data","result","asset","parser","i","parserX","_a","parser2","_b","assetsToLoadIn","onProgress","count","assets","singleAsset","isSingleItem","assetsToLoad","convertToList","item","total","promises","utils.path","e","assetsToUnloadIn","loadPromise","loadedAsset","hash"],"mappings":"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","x_google_ignoreList":[0]}