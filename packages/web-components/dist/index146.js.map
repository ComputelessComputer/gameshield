{"version":3,"file":"index146.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/assets/Assets.mjs"],"sourcesContent":["import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { loadBitmapFont, bitmapFontCachePlugin } from '../scene/text-bitmap/asset/loadBitmapFont.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nimport { detectAvif } from './detections/parsers/detectAvif.mjs';\nimport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nimport { detectMp4 } from './detections/parsers/detectMp4.mjs';\nimport { detectOgv } from './detections/parsers/detectOgv.mjs';\nimport { detectWebm } from './detections/parsers/detectWebm.mjs';\nimport { detectWebp } from './detections/parsers/detectWebp.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { loadJson } from './loader/parsers/loadJson.mjs';\nimport { loadTxt } from './loader/parsers/loadTxt.mjs';\nimport { loadWebFont } from './loader/parsers/loadWebFont.mjs';\nimport { loadSvg } from './loader/parsers/textures/loadSVG.mjs';\nimport { loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures.mjs';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl.mjs';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny.{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  loadBitmapFont,\n  bitmapFontCachePlugin,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n\nexport { Assets, AssetsClass };\n//# sourceMappingURL=Assets.mjs.map\n"],"names":["AssetsClass","Resolver","Loader","Cache","BackgroundLoader","options","warn","manifest","resolutionPref","_a","resolution","formats","_b","assets","urls","onProgress","singleAsset","isSingleItem","urlArray","convertToList","url","aliases","alias","resolveResults","out","bundleId","bundleIds","keys","count","total","_onProgress","promises","resolveResult","resolveResult2","i","resolveArray","loadedAssets","asset","key","detection","format","index","preferences","parser","Assets","extensions","ExtensionType","cacheTextureArray","detectDefaults","detectAvif","detectWebp","detectMp4","detectOgv","detectWebm","loadJson","loadTxt","loadWebFont","loadSvg","loadTextures","loadVideoTextures","loadBitmapFont","bitmapFontCachePlugin","resolveTextureUrl","resolveJsonUrl","assetKeyMap","extension","ref","type"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AA0BA,MAAMA,EAAY;AAAA,EAChB,cAAc;AACZ,SAAK,cAAc,IACnB,KAAK,eAAe,IACpB,KAAK,WAAW,IAAIC,KACpB,KAAK,SAAS,IAAIC,KAClB,KAAK,QAAQC,GACb,KAAK,oBAAoB,IAAIC,EAAiB,KAAK,MAAM,GACzD,KAAK,kBAAkB,SAAS,IAChC,KAAK,MAAK;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,MAAM,KAAKC,IAAU,IAAI;;AACvB,QAAI,KAAK,cAAc;AACrB,MAAAC,EAAK,2FAA2F;AAChG;AAAA,IACD;AAWD,QAVA,KAAK,eAAe,IAChBD,EAAQ,uBACV,KAAK,SAAS,uBAAuBA,EAAQ,mBAAmB,GAE9DA,EAAQ,aACV,KAAK,SAAS,WAAWA,EAAQ,WAE/BA,EAAQ,oBACV,KAAK,SAAS,oBAAoBA,EAAQ,gBAAgB,GAExDA,EAAQ,UAAU;AACpB,UAAIE,IAAWF,EAAQ;AACvB,MAAI,OAAOE,KAAa,aACtBA,IAAW,MAAM,KAAK,KAAKA,CAAQ,IAErC,KAAK,SAAS,YAAYA,CAAQ;AAAA,IACnC;AACD,UAAMC,MAAiBC,IAAAJ,EAAQ,sBAAR,gBAAAI,EAA2B,eAAc,GAC1DC,IAAa,OAAOF,KAAmB,WAAW,CAACA,CAAc,IAAIA,GACrEG,IAAU,MAAM,KAAK,eAAe;AAAA,MACxC,mBAAkBC,IAAAP,EAAQ,sBAAR,gBAAAO,EAA2B;AAAA,MAC7C,gBAAgBP,EAAQ;AAAA,MACxB,YAAY,KAAK;AAAA,IACvB,CAAK;AACD,SAAK,SAAS,OAAO;AAAA,MACnB,QAAQ;AAAA,QACN,QAAQM;AAAA,QACR,YAAAD;AAAA,MACD;AAAA,IACP,CAAK,GACGL,EAAQ,eACV,KAAK,eAAeA,EAAQ,WAAW;AAAA,EAE1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyCD,IAAIQ,GAAQ;AACV,SAAK,SAAS,IAAIA,CAAM;AAAA,EACzB;AAAA,EACD,MAAM,KAAKC,GAAMC,GAAY;AAC3B,IAAK,KAAK,gBACR,MAAM,KAAK;AAEb,UAAMC,IAAcC,EAAaH,CAAI,GAC/BI,IAAWC,EAAcL,CAAI,EAAE,IAAI,CAACM,MAAQ;AAChD,UAAI,OAAOA,KAAQ,UAAU;AAC3B,cAAMC,IAAU,KAAK,SAAS,SAASD,CAAG;AAC1C,eAAIC,EAAQ,KAAK,CAACC,MAAU,CAAC,KAAK,SAAS,OAAOA,CAAK,CAAC,KACtD,KAAK,IAAIF,CAAG,GAEP,MAAM,QAAQC,CAAO,IAAIA,EAAQ,CAAC,IAAIA;AAAA,MAC9C;AACD,aAAK,KAAK,SAAS,OAAOD,CAAG,KAC3B,KAAK,IAAI,EAAE,OAAOA,GAAK,KAAKA,EAAG,CAAE,GAC5BA;AAAA,IACb,CAAK,GACKG,IAAiB,KAAK,SAAS,QAAQL,CAAQ,GAC/CM,IAAM,MAAM,KAAK,kBAAkBD,GAAgBR,CAAU;AACnE,WAAOC,IAAcQ,EAAIN,EAAS,CAAC,CAAC,IAAIM;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBD,UAAUC,GAAUZ,GAAQ;AAC1B,SAAK,SAAS,UAAUY,GAAUZ,CAAM;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqDD,MAAM,WAAWa,GAAWX,GAAY;AACtC,IAAK,KAAK,gBACR,MAAM,KAAK;AAEb,QAAIC,IAAc;AAClB,IAAI,OAAOU,KAAc,aACvBV,IAAc,IACdU,IAAY,CAACA,CAAS;AAExB,UAAMH,IAAiB,KAAK,SAAS,cAAcG,CAAS,GACtDF,IAAM,CAAA,GACNG,IAAO,OAAO,KAAKJ,CAAc;AACvC,QAAIK,IAAQ,GACRC,IAAQ;AACZ,UAAMC,IAAc,MAAM;AACxB,MAAAf,KAAA,QAAAA,EAAa,EAAEa,IAAQC;AAAA,IAC7B,GACUE,IAAWJ,EAAK,IAAI,CAACF,MAAa;AACtC,YAAMO,IAAgBT,EAAeE,CAAQ;AAC7C,aAAAI,KAAS,OAAO,KAAKG,CAAa,EAAE,QAC7B,KAAK,kBAAkBA,GAAeF,CAAW,EAAE,KAAK,CAACG,MAAmB;AACjF,QAAAT,EAAIC,CAAQ,IAAIQ;AAAA,MACxB,CAAO;AAAA,IACP,CAAK;AACD,iBAAM,QAAQ,IAAIF,CAAQ,GACnBf,IAAcQ,EAAIE,EAAU,CAAC,CAAC,IAAIF;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBD,MAAM,eAAeV,GAAM;AACzB,IAAK,KAAK,gBACR,MAAM,KAAK,QAET,OAAOA,KAAS,aAClBA,IAAO,CAACA,CAAI;AAEd,UAAMS,IAAiB,KAAK,SAAS,QAAQT,CAAI;AACjD,SAAK,kBAAkB,IAAI,OAAO,OAAOS,CAAc,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBD,MAAM,qBAAqBG,GAAW;AACpC,IAAK,KAAK,gBACR,MAAM,KAAK,QAET,OAAOA,KAAc,aACvBA,IAAY,CAACA,CAAS;AAExB,UAAMH,IAAiB,KAAK,SAAS,cAAcG,CAAS;AAC5D,WAAO,OAAOH,CAAc,EAAE,QAAQ,CAACS,MAAkB;AACvD,WAAK,kBAAkB,IAAI,OAAO,OAAOA,CAAa,CAAC;AAAA,IAC7D,CAAK;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,QAAQ;AACN,SAAK,SAAS,SACd,KAAK,OAAO,SACZ,KAAK,MAAM,SACX,KAAK,eAAe;AAAA,EACrB;AAAA,EACD,IAAIL,GAAM;AACR,QAAI,OAAOA,KAAS;AAClB,aAAOxB,EAAM,IAAIwB,CAAI;AAEvB,UAAMd,IAAS,CAAA;AACf,aAASqB,IAAI,GAAGA,IAAIP,EAAK,QAAQO;AAC/B,MAAArB,EAAOqB,CAAC,IAAI/B,EAAM,IAAIwB,EAAKO,CAAC,CAAC;AAE/B,WAAOrB;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,MAAM,kBAAkBU,GAAgBR,GAAY;AAClD,UAAMoB,IAAe,CAAC,GAAG,IAAI,IAAI,OAAO,OAAOZ,CAAc,CAAC,CAAC;AAC/D,SAAK,kBAAkB,SAAS;AAChC,UAAMa,IAAe,MAAM,KAAK,OAAO,KAAKD,GAAcpB,CAAU;AACpE,SAAK,kBAAkB,SAAS;AAChC,UAAMS,IAAM,CAAA;AACZ,WAAAW,EAAa,QAAQ,CAACH,MAAkB;AACtC,YAAMK,IAAQD,EAAaJ,EAAc,GAAG,GACtCL,IAAO,CAACK,EAAc,GAAG;AAC/B,MAAIA,EAAc,SAChBL,EAAK,KAAK,GAAGK,EAAc,KAAK,GAElCL,EAAK,QAAQ,CAACW,MAAQ;AACpB,QAAAd,EAAIc,CAAG,IAAID;AAAA,MACnB,CAAO,GACDlC,EAAM,IAAIwB,GAAMU,CAAK;AAAA,IAC3B,CAAK,GACMb;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBD,MAAM,OAAOV,GAAM;AACjB,IAAK,KAAK,gBACR,MAAM,KAAK;AAEb,UAAMI,IAAWC,EAAcL,CAAI,EAAE,IAAI,CAACM,MAAQ,OAAOA,KAAQ,WAAWA,EAAI,MAAMA,CAAG,GACnFG,IAAiB,KAAK,SAAS,QAAQL,CAAQ;AACrD,UAAM,KAAK,oBAAoBK,CAAc;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBD,MAAM,aAAaG,GAAW;AAC5B,IAAK,KAAK,gBACR,MAAM,KAAK,QAEbA,IAAYP,EAAcO,CAAS;AACnC,UAAMH,IAAiB,KAAK,SAAS,cAAcG,CAAS,GACtDK,IAAW,OAAO,KAAKR,CAAc,EAAE,IAAI,CAACE,MAAa,KAAK,oBAAoBF,EAAeE,CAAQ,CAAC,CAAC;AACjH,UAAM,QAAQ,IAAIM,CAAQ;AAAA,EAC3B;AAAA,EACD,MAAM,oBAAoBC,GAAe;AACvC,UAAMG,IAAe,OAAO,OAAOH,CAAa;AAChD,IAAAG,EAAa,QAAQ,CAACF,MAAmB;AACvC,MAAA9B,EAAM,OAAO8B,EAAe,GAAG;AAAA,IACrC,CAAK,GACD,MAAM,KAAK,OAAO,OAAOE,CAAY;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,MAAM,eAAe9B,GAAS;AAC5B,QAAIM,IAAU,CAAA;AACd,IAAIN,EAAQ,qBACVM,IAAU,MAAM,QAAQN,EAAQ,gBAAgB,IAAIA,EAAQ,mBAAmB,CAACA,EAAQ,gBAAgB;AAE1G,eAAWkC,KAAalC,EAAQ;AAC9B,MAAIA,EAAQ,kBAAkB,MAAMkC,EAAU,KAAI,IAChD5B,IAAU,MAAM4B,EAAU,IAAI5B,CAAO,IAC3BN,EAAQ,mBAClBM,IAAU,MAAM4B,EAAU,OAAO5B,CAAO;AAG5C,WAAAA,IAAUA,EAAQ,OAAO,CAAC6B,GAAQC,MAAU9B,EAAQ,QAAQ6B,CAAM,MAAMC,CAAK,GACtE9B;AAAA,EACR;AAAA;AAAA,EAED,IAAI,aAAa;AACf,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,eAAe+B,GAAa;AAC1B,SAAK,OAAO,QAAQ,QAAQ,CAACC,MAAW;AACtC,MAAKA,EAAO,UAEZ,OAAO,KAAKA,EAAO,MAAM,EAAE,OAAO,CAACL,MAAQA,KAAOI,CAAW,EAAE,QAAQ,CAACJ,MAAQ;AAC9E,QAAAK,EAAO,OAAOL,CAAG,IAAII,EAAYJ,CAAG;AAAA,MAC5C,CAAO;AAAA,IACP,CAAK;AAAA,EACF;AACH;AACK,MAACM,IAAS,IAAI5C,EAAc;AACjC6C,EAAW,aAAaC,EAAc,YAAYF,EAAO,OAAO,OAAO,EAAE,aAAaE,EAAc,eAAeF,EAAO,SAAS,OAAO,EAAE,aAAaE,EAAc,aAAaF,EAAO,MAAM,OAAO,EAAE,aAAaE,EAAc,iBAAiBF,EAAO,UAAU;AACvQC,EAAW;AAAA,EACTE;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AACF;AACA,MAAMC,IAAc;AAAA,EAClB,QAAQlB,EAAc;AAAA,EACtB,UAAUA,EAAc;AAAA,EACxB,OAAOA,EAAc;AAAA,EACrB,WAAWA,EAAc;AAC3B;AACAD,EAAW,OAAOC,EAAc,OAAO,CAACmB,MAAc;AACpD,QAAMC,IAAMD,EAAU;AACtB,SAAO,QAAQD,CAAW,EAAE,OAAO,CAAC,CAAC1B,CAAG,MAAM,CAAC,CAAC4B,EAAI5B,CAAG,CAAC,EAAE,QAAQ,CAAC,CAACA,GAAK6B,CAAI,MAAMtB,EAAW,IAAI,OAAO;AAAA,IACvGqB,EAAI5B,CAAG;AAAA;AAAA;AAAA,IAGP,EAAE,WAAW4B,EAAI5B,CAAG,EAAE,aAAa6B,EAAM;AAAA,EAC1C,CAAA,CAAC;AACJ,GAAG,CAACF,MAAc;AAChB,QAAMC,IAAMD,EAAU;AACtB,SAAO,KAAKD,CAAW,EAAE,OAAO,CAAC1B,MAAQ,CAAC,CAAC4B,EAAI5B,CAAG,CAAC,EAAE,QAAQ,CAACA,MAAQO,EAAW,OAAOqB,EAAI5B,CAAG,CAAC,CAAC;AACnG,CAAC;","x_google_ignoreList":[0]}