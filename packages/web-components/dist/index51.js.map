{"version":3,"file":"index51.js","sources":["../../../node_modules/.pnpm/@pixi+core@7.4.3/node_modules/@pixi/core/lib/textures/BaseTexture.mjs"],"sourcesContent":["import { SCALE_MODES, ALPHA_MODES, FORMATS, TYPES, MIPMAP_MODES, WRAP_MODES, TARGETS } from \"@pixi/constants\";\nimport { settings } from \"@pixi/settings\";\nimport { EventEmitter, uid, isPow2, BaseTextureCache, TextureCache } from \"@pixi/utils\";\nimport { autoDetectResource } from \"./resources/autoDetectResource.mjs\";\nimport { BufferResource } from \"./resources/BufferResource.mjs\";\nimport { Resource } from \"./resources/Resource.mjs\";\nconst defaultBufferOptions = {\n  scaleMode: SCALE_MODES.NEAREST,\n  alphaMode: ALPHA_MODES.NPM\n}, _BaseTexture = class _BaseTexture2 extends EventEmitter {\n  /**\n   * @param {PIXI.Resource|PIXI.ImageSource|string} [resource=null] -\n   *        The current resource to use, for things that aren't Resource objects, will be converted\n   *        into a Resource.\n   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.\n   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture\n   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture\n   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures\n   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest\n   * @param {PIXI.FORMATS} [options.format] - GL format type\n   * @param {PIXI.TYPES} [options.type] - GL data type\n   * @param {PIXI.TARGETS} [options.target] - GL texture target\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha\n   * @param {number} [options.width=0] - Width of the texture\n   * @param {number} [options.height=0] - Height of the texture\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture\n   * @param {object} [options.resourceOptions] - Optional resource options,\n   *        see {@link PIXI.autoDetectResource autoDetectResource}\n   */\n  constructor(resource = null, options = null) {\n    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);\n    const {\n      alphaMode,\n      mipmap,\n      anisotropicLevel,\n      scaleMode,\n      width,\n      height,\n      wrapMode,\n      format,\n      type,\n      target,\n      resolution,\n      resourceOptions\n    } = options;\n    resource && !(resource instanceof Resource) && (resource = autoDetectResource(resource, resourceOptions), resource.internal = !0), this.resolution = resolution || settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format, this.type = type, this.target = target, this.alphaMode = alphaMode, this.uid = uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);\n  }\n  /**\n   * Pixel width of the source of this texture\n   * @readonly\n   */\n  get realWidth() {\n    return Math.round(this.width * this.resolution);\n  }\n  /**\n   * Pixel height of the source of this texture\n   * @readonly\n   */\n  get realHeight() {\n    return Math.round(this.height * this.resolution);\n  }\n  /**\n   * Mipmap mode of the texture, affects downscaled images\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  get mipmap() {\n    return this._mipmap;\n  }\n  set mipmap(value) {\n    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);\n  }\n  /**\n   * The scale mode to apply when scaling this texture\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleMode(value) {\n    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * How the texture wraps\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  get wrapMode() {\n    return this._wrapMode;\n  }\n  set wrapMode(value) {\n    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * Changes style options of BaseTexture\n   * @param scaleMode - Pixi scalemode\n   * @param mipmap - enable mipmaps\n   * @returns - this\n   */\n  setStyle(scaleMode, mipmap) {\n    let dirty;\n    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this;\n  }\n  /**\n   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.\n   * @param desiredWidth - Desired visual width\n   * @param desiredHeight - Desired visual height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setSize(desiredWidth, desiredHeight, resolution) {\n    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  }\n  /**\n   * Sets real size of baseTexture, preserves current resolution.\n   * @param realWidth - Full rendered width\n   * @param realHeight - Full rendered height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setRealSize(realWidth, realHeight, resolution) {\n    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  }\n  /**\n   * Changes resolution\n   * @param resolution - res\n   * @returns - this\n   */\n  setResolution(resolution) {\n    const oldResolution = this.resolution;\n    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit(\"update\", this)), this._refreshPOT(), this);\n  }\n  /**\n   * Sets the resource if it wasn't set. Throws error if resource already present\n   * @param resource - that is managing this BaseTexture\n   * @returns - this\n   */\n  setResource(resource) {\n    if (this.resource === resource)\n      return this;\n    if (this.resource)\n      throw new Error(\"Resource can be set only once\");\n    return resource.bind(this), this.resource = resource, this;\n  }\n  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */\n  update() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n  }\n  /**\n   * Handle errors with resources.\n   * @private\n   * @param event - Error event emitted.\n   */\n  onError(event) {\n    this.emit(\"error\", this, event);\n  }\n  /**\n   * Destroys this base texture.\n   * The method stops if resource doesn't want this texture to be destroyed.\n   * Removes texture from all caches.\n   * @fires PIXI.BaseTexture#destroyed\n   */\n  destroy() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.valid = !1, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit(\"destroyed\", this), this.removeAllListeners();\n  }\n  /**\n   * Frees the texture from WebGL memory without destroying this texture object.\n   * This means you can still use the texture later which will upload it to GPU\n   * memory again.\n   * @fires PIXI.BaseTexture#dispose\n   */\n  dispose() {\n    this.emit(\"dispose\", this);\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this;\n  }\n  /**\n   * Helper function that creates a base texture based on the source you provide.\n   * The source can be - image url, image element, canvas element. If the\n   * source is an image url or an image element and not in the base texture\n   * cache, it will be created and loaded.\n   * @static\n   * @param {PIXI.ImageSource|string|string[]} source - The\n   *        source to create base texture from.\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.BaseTexture} The new base texture.\n   */\n  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == \"string\";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source._pixiId = `${prefix}_${uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let baseTexture = BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture)\n      throw new Error(`The cacheId \"${cacheId}\" does not exist in BaseTextureCache.`);\n    return baseTexture || (baseTexture = new _BaseTexture2(source, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   *        Default properties are different from the constructor's defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    const resource = new BufferResource(buffer, { width, height, ...options?.resourceOptions });\n    let format, type;\n    return buffer instanceof Float32Array ? (format = FORMATS.RGBA, type = TYPES.FLOAT) : buffer instanceof Int32Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.INT) : buffer instanceof Uint32Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.SHORT) : buffer instanceof Uint16Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format = FORMATS.RGBA, type = TYPES.BYTE) : (format = FORMATS.RGBA, type = TYPES.UNSIGNED_BYTE), resource.internal = !0, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type, format }, options));\n  }\n  /**\n   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n   * @param {string} id - The id that the BaseTexture will be stored against.\n   */\n  static addToCache(baseTexture, id) {\n    id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), BaseTextureCache[id] = baseTexture);\n  }\n  /**\n   * Remove a BaseTexture from the global BaseTextureCache.\n   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.\n   */\n  static removeFromCache(baseTexture) {\n    if (typeof baseTexture == \"string\") {\n      const baseTextureFromCache = BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache;\n      }\n    } else if (baseTexture?.textureCacheIds) {\n      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n        delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n      return baseTexture.textureCacheIds.length = 0, baseTexture;\n    }\n    return null;\n  }\n};\n_BaseTexture.defaultOptions = {\n  /**\n   * If mipmapping is enabled for texture.\n   * @type {PIXI.MIPMAP_MODES}\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  mipmap: MIPMAP_MODES.POW2,\n  /** Anisotropic filtering level of texture */\n  anisotropicLevel: 0,\n  /**\n   * Default scale mode, linear, nearest.\n   * @type {PIXI.SCALE_MODES}\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  scaleMode: SCALE_MODES.LINEAR,\n  /**\n   * Wrap mode for textures.\n   * @type {PIXI.WRAP_MODES}\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  wrapMode: WRAP_MODES.CLAMP,\n  /**\n   * Pre multiply the image alpha\n   * @type {PIXI.ALPHA_MODES}\n   * @default PIXI.ALPHA_MODES.UNPACK\n   */\n  alphaMode: ALPHA_MODES.UNPACK,\n  /**\n   * GL texture target\n   * @type {PIXI.TARGETS}\n   * @default PIXI.TARGETS.TEXTURE_2D\n   */\n  target: TARGETS.TEXTURE_2D,\n  /**\n   * GL format type\n   * @type {PIXI.FORMATS}\n   * @default PIXI.FORMATS.RGBA\n   */\n  format: FORMATS.RGBA,\n  /**\n   * GL data type\n   * @type {PIXI.TYPES}\n   * @default PIXI.TYPES.UNSIGNED_BYTE\n   */\n  type: TYPES.UNSIGNED_BYTE\n}, /** Global number of the texture batch, used by multi-texture renderers. */\n_BaseTexture._globalBatch = 0;\nlet BaseTexture = _BaseTexture;\nexport {\n  BaseTexture\n};\n//# sourceMappingURL=BaseTexture.mjs.map\n"],"names":["defaultBufferOptions","SCALE_MODES","ALPHA_MODES","_BaseTexture","_BaseTexture2","EventEmitter","resource","options","alphaMode","mipmap","anisotropicLevel","scaleMode","width","height","wrapMode","format","type","target","resolution","resourceOptions","Resource","autoDetectResource","settings","uid","value","dirty","desiredWidth","desiredHeight","realWidth","realHeight","isPow2","oldResolution","event","BaseTextureCache","TextureCache","source","strict","isFrame","cacheId","prefix","baseTexture","buffer","BufferResource","FORMATS","TYPES","id","baseTextureFromCache","index","i","MIPMAP_MODES","WRAP_MODES","TARGETS","BaseTexture"],"mappings":"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","x_google_ignoreList":[0]}