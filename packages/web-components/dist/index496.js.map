{"version":3,"file":"index496.js","sources":["../../../node_modules/.pnpm/pixi.js@8.8.1/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"],"sourcesContent":["import { Point } from '../../../maths/point/Point.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.apply(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.applyInverse(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n"],"names":["toLocalGlobalMixin","point","Point","skipUpdate","position","globalMatrix","matrixPool","from"],"mappings":";;AAIK,MAACA,IAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzB,kBAAkBC,IAAQ,IAAIC,EAAK,GAAIC,IAAa,IAAO;AACzD,WAAI,KAAK,SACP,KAAK,OAAO,SAAS,KAAK,WAAWF,GAAOE,CAAU,KAEtDF,EAAM,IAAI,KAAK,UAAU,GACzBA,EAAM,IAAI,KAAK,UAAU,IAEpBA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,SAASG,GAAUH,GAAOE,IAAa,IAAO;AAC5C,UAAME,IAAe,KAAK,mBAAmBC,EAAW,IAAG,GAAIH,CAAU;AACzE,WAAAF,IAAQI,EAAa,MAAMD,GAAUH,CAAK,GAC1CK,EAAW,OAAOD,CAAY,GACvBJ;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWD,QAAQG,GAAUG,GAAMN,GAAOE,GAAY;AACzC,IAAII,MACFH,IAAWG,EAAK,SAASH,GAAUH,GAAOE,CAAU;AAEtD,UAAME,IAAe,KAAK,mBAAmBC,EAAW,IAAG,GAAIH,CAAU;AACzE,WAAAF,IAAQI,EAAa,aAAaD,GAAUH,CAAK,GACjDK,EAAW,OAAOD,CAAY,GACvBJ;AAAA,EACR;AACH;","x_google_ignoreList":[0]}